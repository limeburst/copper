<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./intro.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="./audience.html"><strong>1.1.</strong> Audience</a></li><li><a href="./why-rust.html"><strong>1.2.</strong> Why Rust?</a></li><li><a href="./why-arm.html"><strong>1.3.</strong> Why ARM Cortex-M micros?</a></li><li><a href="./what-dev-board.html"><strong>1.4.</strong> What dev board should I use/get?</a></li></ul></li><li><a href="./tools.html"><strong>2.</strong> Setting up a development environment</a></li><li><ul class="section"><li><a href="./linux.html"><strong>2.1.</strong> Linux</a></li><li><a href="./macos.html"><strong>2.2.</strong> macOS</a></li><li><a href="./windows.html"><strong>2.3.</strong> Windows</a></li></ul></li><li><a href="./first/prog.html"><strong>3.</strong> First program</a></li><li><ul class="section"><li><a href="./first/build.html" class="active"><strong>3.1.</strong> Build &amp; inspect</a></li><li><a href="./first/qemu.html"><strong>3.2.</strong> Run it under QEMU</a></li><li><a href="./details.html"><strong>3.3.</strong> Nitty-gritty details</a></li><li><ul class="section"><li><a href="./details/target.html"><strong>3.3.1.</strong> Target specification</a></li><li><a href="./details/boot.html"><strong>3.3.2.</strong> Boot process</a></li><li><a href="./details/ld.html"><strong>3.3.3.</strong> Linker script</a></li></ul></li><li><a href="./first/flash.html"><strong>3.4.</strong> Run it on real hardware</a></li></ul></li><li><a href="./exceptions.html"><strong>4.</strong> Exceptions: Crashing your micro</a></li><li><a href="./blink.html"><strong>5.</strong> Blinking an LED</a></li><li class="spacer"></li><li class="affix">Work In Progress chapters</li><li class="affix"><a href="./optimize.html">(Mis)Optimization</a></li><li class="affix"><a href="registers.html">Zero-cost type-safe register manipulation</a></li><li class="affix"><a href="hal.html">Abstracting Hardware</a></li><li class="affix"><a href="./peripherals.html">Peripherals</a></li><li class="spacer"></li><li class="affix"><a href="./unwritten.html">Unwritten topics</a></li><li class="spacer"></li><li class="affix"><a href="./resources.html">Resources</a></li><li class="affix"><a href="./faq.html">FAQ</a></li><li class="spacer"></li><li class="affix">Published using mdBook</li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Build &amp; inspect</h1>
<p>Let's start by creating a new Cargo project:</p>
<pre><code>$ cargo new --bin app &amp;&amp; cd $_
</code></pre>
<p>And then add these files to the project:</p>
<ul>
<li><a href="./first/layout.ld">layout.ld</a> - a &quot;linker script&quot;</li>
<li><a href="./first/cortex-m3.json">cortex-m3.json</a> - a &quot;target specification file&quot;</li>
<li><a href="./first/main.rs">src/main.rs</a></li>
</ul>
<p>I'll explain what these two first files are for in a later section. It's not important to know what
they do <em>right now</em>.</p>
<p>Your project directory should look like this:</p>
<pre><code>$ tree .
</code></pre>
<pre><code>.
├── Cargo.toml
├── cortex-m3.json
├── layout.ld
└── src
    └── main.rs
</code></pre>
<p>For convenience, <code>src/main.rs</code> is replicated here:</p>
<pre><code class="language-rust">#![feature(lang_items)]

// We won't use the usual `main` function. We are going to use a different &quot;entry point&quot;.
#![no_main]

// We won't use the standard library because it requires OS abstractions like threads and files and
// those are not available in this platform.
#![no_std]

// Conceptually, this is our program &quot;entry point&quot;. It's the first thing the microcontroller will
// execute when it (re)boots. (As far as the linker is concerned the entry point must be named
// `start` (by default; it can have a different name). That's why this function is `pub`lic, named
// `start` and is marked as `#[no_mangle]`.)
//
// Returning from this function is undefined because there is nothing to return to! To statically
// forbid returning from this function, we mark it as divergent, hence the `fn() -&gt; !` signature.
#[no_mangle]
pub fn start() -&gt; ! {
    // Our first program initializes some variables on the stack and does nothing more. Yay!
    let x = 42;
    let y = x;

    // We can't return from this function so we just spin endlessly here.
    loop {}
}

// Ignore this part for now :-). It will covered in a later section.
mod vector_table {
    #[link_section = &quot;.reset&quot;]
    static RESET: fn() -&gt; ! = ::start;
}

// Finally, we need to define some &quot;lang items&quot; we are _not_ going to use, but that `rustc` demands
// anyway. As we are not going to use the functionality they provide (panic/unwinding) we can left
// their definitions empty.
mod lang_items {
    #[lang = &quot;panic_fmt&quot;]
    fn panic_fmt() {}

    #[lang = &quot;eh_personality&quot;]
    fn eh_personality() {}
}
</code></pre>
<p>If you have written a native Rust program before, this shouldn't look that different. It's just as
if our &quot;<code>main</code>&quot; function, which in this case is named <code>start</code>, has a different signature.</p>
<p>Now build the project:</p>
<pre><code>$ xargo build --target cortex-m3
</code></pre>
<pre><code>   Compiling app v0.1.0
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Do <strong>not</strong> build the project in release mode!</p>
</blockquote>
<h2>Trust, but verify</h2>
<p>The project appeared to build fine, but it's always a good idea to inspect the executable. We are
going to look at three things:</p>
<h3>Memory layout</h3>
<p>First, you have to appreciate the fact that, during its execution, everything in a program resides
in memory and has an associated memory address. Now, everything that's <em>statically allocated</em>, like
functions and static variables, gets assigned an address at compile time. Whereas, everything else,
like local/stack variables and &quot;heap&quot; allocated variables, gets assigned an address at runtime.</p>
<p>We can observe the addresses of statically allocated stuff using <code>objdump</code>. Let's check our
executable:</p>
<pre><code># with
$ arm-none-eabi-objdump --demangle --disassemble-all target/cortex-m3/debug/app
# or with the equivalent
$ arm-none-eabi-objdump -CD target/cortex-m3/debug/app
</code></pre>
<pre><code>target/cortex-m3/debug/app:     file format elf32-littlearm


Disassembly of section .vector_table:

00000000 &lt;app::vector_table::RESET::ha7f0c0bde3147d64-0x4&gt;:
   0:   20010000    andcs   r0, r1, r0

00000004 &lt;app::vector_table::RESET::ha7f0c0bde3147d64&gt;:
   4:   00000009    andeq   r0, r0, r9

Disassembly of section .text:

00000008 &lt;start&gt;:
   8:   b082        sub sp, #8
   a:   202a        movs    r0, #42 ; 0x2a
   c:   9001        str r0, [sp, #4]
   e:   9000        str r0, [sp, #0]
  10:   e7ff        b.n 12 &lt;start+0xa&gt;
  12:   e7fe        b.n 12 &lt;start+0xa&gt;

(...)
</code></pre>
<p>Let me highlight the important bits of the output:</p>
<pre><code>
00000000
   0:   20010000

00000004
   4:   00000009

00000008 &lt;start&gt;:
   8:               sub sp, #8
   a:               movs    r0, #42 ; 0x2a
   c:               str r0, [sp, #4]
   e:               str r0, [sp, #0]
  10:               b.n 12 &lt;start+0xa&gt;
  12:               b.n 12 &lt;start+0xa&gt;
</code></pre>
<p>Now let's read the output section by section:</p>
<pre><code>00000000
   0:   20010000
</code></pre>
<p>&quot;The memory at address <code>0x0</code> holds the (<code>u32</code>) value <code>0x2001_0000</code>&quot;. When the program starts its
execution, that part of the memory will be already initialized to that value.</p>
<pre><code>00000004
   4:   00000009
</code></pre>
<p>Likewise, &quot;the memory at <code>0x4</code> holds the  (<code>u32</code>) value <code>0x9</code>&quot;.</p>
<pre><code>00000008 &lt;start&gt;:
   8:               sub sp, #8
   a:               movs    r0, #42 ; 0x2a
   c:               str r0, [sp, #4]
   e:               str r0, [sp, #0]
  10:               b.n 12 &lt;start+0xa&gt;
  12:               b.n 12 &lt;start+0xa&gt;
</code></pre>
<p>Finally, &quot;the <code>start</code> function resides at address <code>0x8</code>&quot;. The lines, like <code>sub sp, #8</code>, below
<code>&lt;start&gt;</code> are the instructions that make up the function. When the processor executes this function,
it will execute each one of these instructions.</p>
<p>But, why are these addresses/values important? During boot up, the microcontroller reads the memory
section at <code>0x0..0x8</code> and uses those  values to perform the boot process. In other words, the values
in that memory section have an special meaning to the boot process. In a <a href="details/boot.html">later section</a>, I'll
explain what those values mean and how they are used in the boot process. For now, it's okay to just
confirm that the memory at <code>0x0..0x8</code> is initialized.</p>
<h3>Program size</h3>
<p>Microcontrollers are memory constrained devices. It's important to keep an eye on the size of our
programs to make sure they don't exceed the memory capacity of our device. We'll use the <code>size</code>
command to do that:</p>
<pre><code>$ arm-none-eabi-size target/cortex-m3/debug/app
</code></pre>
<pre><code>   text    data     bss     dec     hex filename
     20       0       0      20      14 target/cortex-m3/debug/app
</code></pre>
<p>The output mentions three different memory <em>sections</em>:</p>
<ul>
<li>The <code>text</code> section contains the &quot;program code&quot;, i.e. all the instructions that the processor will
execute when the program is executed. Functions go in this section. This section also stores
constants like strings. <code>static CONSTANT: &amp;'static str = &quot;Hello, world!&quot;</code>is an example of a
constant.</li>
<li><code>data</code> holds static variables that have an initial value, for example <code>static mut X: i32 = 42</code>.</li>
<li>On the contrary, <code>bss</code> holds &quot;uninitialized&quot; static variables. Because of C heritage, here
&quot;uninitialized&quot; actually means <em>zeroed</em>. For example, <code>static mut ZEROS: [u8; 4] = [0; 4]</code> would
go in this section.</li>
</ul>
<p><code>dec</code> is just the sum of these three sections and <code>hex</code> is the hexadecimal representation of <code>dec</code>.</p>
<p>Our program size is just 20 bytes big! Microcontrollers usually have memory capacities in the order
of a few KiB up to hundreds of KiB. In particular, the LM3S6965 microcontroller, which we are going
to emulate, has 256KiB of (Flash) memory. So, no problem here; this program will fit in the device
memory.</p>
<blockquote>
<p><strong>NOTE</strong> KiB = <a href="https://en.wikipedia.org/wiki/Kibibyte">Kibibyte</a> = 1024 bytes</p>
</blockquote>
<h3>Entry point</h3>
<p>To work properly, tools like <code>gdb</code> and <code>qemu</code> need to be informed about the program entry point,
which is where the program starts its execution.</p>
<p>We can check our program entry point using the <code>readelf</code> command:</p>
<pre><code>$ arm-none-eabi-readelf -h target/cortex-m3/debug/app
</code></pre>
<pre><code>ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           ARM
  Version:                           0x1
  Entry point address:               0x8
  Start of program headers:          52 (bytes into file)
  Start of section headers:          67748 (bytes into file)
  Flags:                             0x5000202, has entry point, Version5 EABI, soft-float ABI
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         16
  Section header string table index: 13
</code></pre>
<p>There you can see that <code>0x8</code> is the entry point address. From the previous <code>objdump</code> output, you
know that <code>0x8</code> is the address of the <code>start</code> function. This means that the entry point have been
correctly declared.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="./first/prog.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="./first/qemu.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./first/prog.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./first/qemu.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
