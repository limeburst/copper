<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./intro.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="./audience.html"><strong>1.1.</strong> Audience</a></li><li><a href="./why-rust.html"><strong>1.2.</strong> Why Rust?</a></li><li><a href="./why-arm.html"><strong>1.3.</strong> Why ARM Cortex-M micros?</a></li><li><a href="./what-dev-board.html"><strong>1.4.</strong> What dev board should I use/get?</a></li></ul></li><li><a href="./tools.html"><strong>2.</strong> Setting up a development environment</a></li><li><ul class="section"><li><a href="./linux.html"><strong>2.1.</strong> Linux</a></li><li><a href="./macos.html"><strong>2.2.</strong> macOS</a></li><li><a href="./windows.html"><strong>2.3.</strong> Windows</a></li></ul></li><li><a href="./first/prog.html"><strong>3.</strong> First program</a></li><li><ul class="section"><li><a href="./first/build.html"><strong>3.1.</strong> Build &amp; inspect</a></li><li><a href="./first/qemu.html"><strong>3.2.</strong> Run it under QEMU</a></li><li><a href="./details.html"><strong>3.3.</strong> Nitty-gritty details</a></li><li><ul class="section"><li><a href="./details/target.html"><strong>3.3.1.</strong> Target specification</a></li><li><a href="./details/boot.html"><strong>3.3.2.</strong> Boot process</a></li><li><a href="./details/ld.html"><strong>3.3.3.</strong> Linker script</a></li></ul></li><li><a href="./first/flash.html"><strong>3.4.</strong> Run it on real hardware</a></li></ul></li><li><a href="./exceptions.html"><strong>4.</strong> Exceptions: Crashing your micro</a></li><li><a href="./blink.html"><strong>5.</strong> Blinking an LED</a></li><li class="spacer"></li><li class="affix">Work In Progress chapters</li><li class="affix"><a href="./optimize.html">(Mis)Optimization</a></li><li class="affix"><a href="registers.html">Zero-cost type-safe register manipulation</a></li><li class="affix"><a href="hal.html">Abstracting Hardware</a></li><li class="affix"><a href="./peripherals.html">Peripherals</a></li><li class="spacer"></li><li class="affix"><a href="./unwritten.html">Unwritten topics</a></li><li class="spacer"></li><li class="affix"><a href="./resources.html">Resources</a></li><li class="affix"><a href="./faq.html">FAQ</a></li><li class="spacer"></li><li class="affix">Published using mdBook</li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Introduction</h1>
<blockquote>
<p><strong>WARNING</strong> This is a work in progress! It's incomplete and some chapters/sections are still in
draft phase.</p>
</blockquote>
<blockquote>
<p><strong>TODO</strong> Add a GIF of a cool demo</p>
</blockquote>
<p>The goal of this book is to get you started in <em>microcontroller software development</em>. We'll mainly
cover <em>bare metal programming</em> (programming directly <em>on</em> hardware, without OS
abstractions/services) but I hope we'll tread into OS development territory (e.g. schedulers) in the
latter chapters. We'll use the <a href="https://www.rust-lang.org/">Rust programming language</a> and ARM <a href="http://www.arm.com/products/processors/cortex-m/index.php?tab=Why+Cortex-M?">Cortex-M</a> microcontrollers as a
means to that end.</p>
<blockquote>
<p><strong>TODO</strong> What are microcontrollers? micros vs general purpose computers. What are the differences
between programming a micro and programming a general purpose computer? etc. -- In other words,
I'm going to assume you already know <em>why</em> you want to learn to program microcontrollers in the
first place. :-)</p>
</blockquote>
<p>(Hopefully) At the end of this book the reader will:</p>
<ul>
<li>Be able to program any (ARM Cortex-M) microcontroller that's supported by the Rust compiler and is
minimally/properly documented.</li>
<li>Become familiar with the <em>peripherals</em> (functionality) commonly provided by microcontrollers:
analog/digital I/O, communication protocols, timers, etc.</li>
<li>Be able to write drivers for these peripherals and be able to compose them into applications.</li>
<li>Know how to use existing (C) tooling to inspect, profile and debug the program they wrote.</li>
</ul>
<blockquote>
<p><strong>DISCLAIMER</strong> I don't claim to be an authority on embedded software development and much less an
authority on embedded software development <em>with Rust</em>. The abstractions, programming patterns and
development methods I present here are probably <em>not</em> the best practices because we don't know
yet what those look like in Rust! I hope this book will trigger more interest and discussion on
this topic and <em>that</em> will hopefully lead to the development of best practices.</p>
</blockquote>
<h2>Contact</h2>
<p>If you:</p>
<ul>
<li>Would like to report any issue with this text: a typo, wrong/unclear information or
missing/insufficient background information.</li>
<li>Would like to see a chapter on some specific topic (but check <a href="/unwritten.html">this list</a> first)</li>
<li>Have any question about the topics covered here</li>
<li>Would like to share an idea, suggestion or critic</li>
<li>Just want to say hi, thanks or whatever is on your mind</li>
</ul>
<p>Feel free to contact <a href="https://github.com/japaric">me</a> via e-mail, the <a href="https://github.com/japaric/copper/issues">issue tracker</a> or this <a href="https://gitter.im/japaric/copper">gitter channel</a>.</p>
<h2>Source</h2>
<p>The source of this document is available in <a href="https://github.com/japaric/copper">this repository</a>. Pull requests fixing typos or
improving the wording are welcome!</p>
<h1>Audience</h1>
<blockquote>
<p>Who is this documentation aimed towards?</p>
</blockquote>
<p>This site is aimed at people that:</p>
<ul>
<li>Have a basic knowledge of Rust. If you haven't been introduced to Rust yet, you should check out
the (Rust) <a href="https://doc.rust-lang.org/book/">&quot;book&quot;</a> and <a href="https://github.com/ctjhoa/rust-learning">these other great learning resources</a>.</li>
</ul>
<ul>
<li>Have access, own, or are willing to buy an ARM Cortex-M development board.</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> You <em>can</em> follow this material <em>without</em> a dev board by using an emulator. But your
learning experience (and enjoyment!) will likely suffer as you will only be able to execute a few
of the programs that we'll develop here due to limitations in emulators (not all the
microcontroller functionality is implemented).</p>
</blockquote>
<p>On the other hand, you <strong>don't</strong> need to know about any of these topics to follow this material:</p>
<ul>
<li>Assembly.</li>
<li>Electronics.</li>
<li>Microcontrollers.</li>
<li>The ARM (Cortex-M) architecture.</li>
<li>The C programming language.</li>
</ul>
<p>If you are already familiar with embedded development using C/C++, please tag along! I'm sure you'll
find the information about tooling (Cargo instead of Make) and Rust abstractions (traits as
interfaces) interesting. Plus, I'd love to hear your opinion about how non-Rust concepts (like the
ARM boot process, linker scripts, etc) are explained.</p>
<h1>Why Rust?</h1>
<blockquote>
<p>Why program in Rust and not in C?</p>
</blockquote>
<p>C is (probably) the most used programming language for development of embedded systems (citation
needed). However I've decided to use Rust in this material for the following reasons:</p>
<ul>
<li>Rust gives you C-like low level control over aspects like memory management and struct layout /
memory representation while not imposing a runtime and still providing high level features like
closures, traits/generics, tagged unions, pattern matching and someday, I hope, (state-machine)
<a href="https://github.com/rust-lang/rfcs/issues/1081#issuecomment-221396554">generators</a> (this <a href="https://dwrensha.github.io/capnproto-rust/2016/05/28/async-generators.html">blog post</a> fleshes out the idea a bit more).</li>
</ul>
<ul>
<li>
<p>The Rust distribution ships with a package manager, Cargo, that encourages splitting your
programs in reusable crates (libraries) by greatly simplifying dependency management. Cargo also
encourages not reinventing the wheel by providing access to a central repository where the Rust
community publishes and shares their crates.</p>
</li>
<li>
<p>One can use pretty much all of the existing C tooling on Rust programs. For example:</p>
<ul>
<li>You can use binary inspection tools like <code>objdump</code>, <code>nm</code>, <code>readelf</code>, <code>size</code>, etc.</li>
<li>You can use <code>gdb</code>/<code>lldb</code> to debug your program. Things like step-by-step execution, breakpoints,
watchpoints, printing variables, etc. Just Work.</li>
<li>You can run your program under an emulator like QEMU.</li>
</ul>
</li>
<li>
<p>Some people find Rust more approachable and/or less scary than C. This means that they are more
likely to explore this area of programming using Rust than using C.</p>
</li>
<li>
<p>And, most importantly, I like Rust and its awesome community.</p>
</li>
</ul>
<blockquote>
<p><strong>TODO</strong> Rust &amp; C++ comparison</p>
</blockquote>
<h2>Disadvantages of not using C</h2>
<p>Or advantages of using C instead of Rust:</p>
<ul>
<li>
<p>Device support. Some less known architectures, like the Xtensa, but with huge communities behind
them, like the ESP8266 (google it!), are not supported by LLVM and therefore you can't build Rust
programs for microcontrollers of that architecture.</p>
</li>
<li>
<p>Commercial/IDE support. There are lots (compared to Rust) of commercial IDEs, SDKs, RTOSes for
developing firmware in C.</p>
</li>
</ul>
<blockquote>
<p><strong>TODO</strong> More advantages of using C. I haven't though this thoroughly.</p>
</blockquote>
<h1>Why the ARM Cortex-M?</h1>
<blockquote>
<p>Why not AVR or PIC or ...?</p>
</blockquote>
<p>The main reason is that there are not many microcontroller families that are currently supported by
Rust. Popular microcontrollers like AVR and PIC are, currently, not (oficially) supported by LLVM
and as the Rust compiler relies on LLVM for code generation it doesn't support them either. However,
an <a href="https://github.com/avr-llvm/llvm">unofficial AVR backend</a> for LLVM is currently undergoing the process of being merged back
into upstream LLVM, so this situation will likely improve in the near future.</p>
<p>Do note that some of the concepts covered here like the tooling and how to use common peripherals
are transferable to other microcontroller families.</p>
<h1>What dev board should I use/get?</h1>
<blockquote>
<p><strong>FIXME</strong> I haven't defined what a &quot;dev board&quot; is yet!</p>
</blockquote>
<p>I won't force you to use a specific dev board. This document has been written in a device-agnostic
way so you can follow it with pretty much any dev board you want. Nonetheless, some dev boards are
more easy to work with than others. This section will provide you some advice on how to pick a dev
board that will make your life easier.</p>
<p>Get/use a dev board:</p>
<h2>That's supported by the OpenOCD project.</h2>
<p>We'll use OpenOCD to &quot;flash&quot; and debug the programs we'll develop. It's best if you can get a dev
board with a built-in debugger that's supported by OpenOCD. You can see a list of such boards
<a href="https://github.com/ntfreak/openocd/tree/master/tcl/board">here</a>.</p>
<blockquote>
<p><strong>NOTE</strong> Not all the dev boards listed in that link have an ARM Cortex-M microcontroller, some of
them have Cortex-A processors, some have microcontrollers with a different architecture (e.g.
AVR).</p>
</blockquote>
<p>One example of such dev board is the <a href="http://www.st.com/content/st_com/en/products/evaluation-tools/product-evaluation-tools/mcu-eval-tools/stm32-mcu-eval-tools/stm32-mcu-discovery-kits/stm32vldiscovery.html?sc=stm32-discovery">STM32VLDISCOVERY</a> which I'm going to use throughout the
examples of this document. It seems that most of the <a href="http://www.st.com/content/st_com/en/products/evaluation-tools/product-evaluation-tools/mcu-eval-tools/stm32-mcu-eval-tools.html?querycriteria=productId=SS1532">other evaluation boards</a> by STM32 also have
a built-in debugger and are supported by OpenOCD. I'm not familiar with other vendors like Atmel and
NXP but they probably have similar offerings.</p>
<blockquote>
<p><strong>TODO</strong> Add picture of the STM32VLDISCOVERY</p>
</blockquote>
<p>Alternatively, you can use a board that doesn't have a built-in debugger if the microcontroller in
it is supported by OpenOCD (check <a href="https://github.com/ntfreak/openocd/tree/master/tcl/target">this list</a>) and the board exposes a JTAG/SWD connector,
but you'll also need an external debugger supported by OpenOCD (check <a href="https://github.com/ntfreak/openocd/tree/master/tcl/interface">this list</a>). This
is more complicated as you'll have to read about the JTAG/SWD interface to make an informed decision
and you'll also have to figure out how to wire up everything together.</p>
<blockquote>
<p><strong>NOTE</strong> The &quot;target list&quot; linked above not only contains Cortex-M microcontrollers but also
devices with different architectures. Likewise, the &quot;interface list&quot; linked above not only lists
JTAG/SWD interfaces.</p>
</blockquote>
<blockquote>
<p><strong>TODO</strong> Add picture of what the connection looks like</p>
</blockquote>
<h2>That has good documentation</h2>
<p>The microcontroller in it should have documentation about:</p>
<ul>
<li>The peripherals it provides: How they work and the registers associated with them. This document
is known as the <em>Reference Manual</em> (<a href="http://www.st.com/resource/en/reference_manual/cd00246267.pdf">example</a>), although sometimes this information is
contained in the <em>Data Sheet</em> (<a href="http://www.ti.com/lit/ds/symlink/lm3s6965.pdf">example</a>).</li>
<li>Hardware bugs (yes, hardware can have bugs too!) or device limitations that may be present in the
revision of the hardware that you own and how to work around them. This document is known as
<em>Silicon Errata</em> or just <em>Errata Sheet</em> (<a href="http://www.st.com/resource/en/errata_sheet/cd00260217.pdf">example</a>).</li>
</ul>
<h1>Setting up a development environment</h1>
<p>Working with embedded systems requires extra tooling as cross compilation is at the heart of the
development process. This chapter will introduce the tools we'll use, why we need them and how to
install them on the 3 major OSes.</p>
<p>Without further ado, these are the tools we'll use:</p>
<ul>
<li><a href="/setup.html#Rust%20%26%20Cargo%3A%20nightly%20edition">Rust &amp; Cargo: nightly edition</a></li>
<li><a href="/setup.html#A%20cross%20C%20linker%3A%20arm-none-eabi-gcc">A cross C linker: arm-none-eabi-gcc</a></li>
<li><a href="/setup.html#Binary%20inspection%20tools">Binary inspection tools</a>
<ul>
<li><a href="/setup.html#arm-none-eabi-objdump">arm-none-eabi-objdump</a></li>
<li><a href="/setup.html#arm-none-eabi-size">arm-none-eabi-size</a></li>
</ul>
</li>
<li><a href="/setup.html#A%20debugger">A debugger</a></li>
<li><a href="/setup.html#An%20emulator%3A%20QEMU">An emulator: QEMU</a></li>
<li><a href="/setup.html#Xargo">Xargo</a></li>
<li><a href="/setup.html#OpenOCD">OpenOCD</a></li>
</ul>
<p>The rest of this page will justify each of these tools. For installation instructions check the
subsections of this chapter: <a href="/linux.html">Linux</a>, <a href="/osx.html">Mac</a> and <a href="/windows.html">Windows</a></p>
<h2>Rust &amp; Cargo: nightly edition</h2>
<p>Rust &amp; Cargo don't need  much explanation. To build Rust programs we'll need the Rust compiler,
<code>rustc</code>, and the Rust package manager, Cargo.</p>
<p>What does need justification is the use of the nightly channel. We need to use the nightly channel
because we'll make use of the following unstable features:</p>
<ul>
<li><code>asm</code>: We'll use some inline assembly via the <code>asm!</code> syntax extension. But that syntax extension
hasn't been stabilized.</li>
<li><code>lang_items</code>: The need for this feature gate is sometimes artificial. The compiler demands some
lang times, like <code>eh_personality</code> and <code>panic_fmt</code>, to be defined even if the functionality they
provide (unwinding/panicking) is never used in our program.</li>
<li>To cross compile programs we need a cross compiled <code>core</code> crate. The Rust project doesn't
distribute a binary release of that crate for Cortex-M microcontrollers so we have to cross
compile that crate ourselves. As the <code>core</code> crate relies on lots of unstable features, we have to
use the nightly channel to cross compile it.</li>
</ul>
<h2>A cross C linker: <code>arm-none-eabi-gcc</code></h2>
<p>(<code>arm-none-eabi-gcc</code> is not a linker per se but <code>rustc</code> uses it as a proxy for <code>arm-none-eabi-ld</code>.)</p>
<blockquote>
<p>Wait, aren't we going to write Rust? Why do we need a <em>C compiler</em>?</p>
</blockquote>
<p><code>rustc</code> uses <code>gcc</code> to link intermediate object files so we pretty much have no choice.</p>
<h2>Binary inspection tools</h2>
<p>When working this close to the hardware and with devices that have constrained resources and
mandatory memory layouts, it's pretty important to inspect the produced binaries to keep track of
their sizes and to check that the produced binaries follow a specific memory layout.</p>
<p>We'll mainly use the following two tools:</p>
<h3><code>arm-none-eabi-size</code></h3>
<p>To keep an eye on the binary size of our applications.</p>
<h3><code>arm-none-eabi-objdump</code></h3>
<p>To confirm the memory layout of our program matches the memory layout constraints of the target
device.</p>
<h2>A debugger</h2>
<p>A debugger is vital when working with microcontrollers as other debugging methods like logging or
<em>cough</em> <code>println</code> may not be available. This is specially true when you are just starting out and
haven't yet written drivers for peripherals that allow microcontroller &lt;-&gt; PC communication.</p>
<p>We'll mainly use <code>arm-none-eabi-gdb</code> in this document as <code>lldb</code> doesn't provide all the
functionality we need.</p>
<h2>An emulator: QEMU</h2>
<p>Before trying out our first program on real hardware, we'll run it under an emulator to verify that
the program works as expected.</p>
<h2>Xargo</h2>
<p>In general, cross compiling requires cross compiled &quot;standard&quot; crates like the <code>core</code> or the <code>std</code>
crate. Binary releases of these crates for Cortex-M microcontrollers are not provided by the
Rust project so we'll have to cross compile these ourselves. Just cross compiling is not enough
though, as one must place the produced binaries in a specific directory layout called a &quot;sysroot&quot;.
Because this process is cumbersome and error prone, I have <a href="https://github.com/japaric/xargo">created Xargo</a>. Xargo is a <em>transparent</em>
Cargo wrapper that automatically builds and manages sysroots without user intervention.</p>
<p>Usage looks like this:</p>
<pre><code>$ cargo build --target cortex-m3 &amp;&amp; echo OK
</code></pre>
<pre><code>   Compiling app v0.1.0
error: can't find crate for `core` [E0463]

error: aborting due to previous error
error: Could not compile `app`.

To learn more, run the command again with --verbose.
</code></pre>
<pre><code>$ xargo build --target cortex-m3 &amp;&amp; echo OK
</code></pre>
<pre><code> Downloading https://static.rust-lang.org/dist/2016-07-04/rustc-nightly-src.tar.gz
   Unpacking rustc-nightly-src.tar.gz
   Compiling sysroot for cortex-m3
   Compiling core v0.0.0
   Compiling app v0.1.0
OK
</code></pre>
<h2>OpenOCD</h2>
<p><a href="/setup.html#OpenOCD">OpenOCD</a> is a tool that lets your computer communicate with devices that support the JTAG/SWD
communication protocol. We'll use OpenOCD to <em>flash</em> (write) our programs into the microcontroller
and to debug them (with the help of <code>gdb</code>).</p>
<h1>Linux</h1>
<h2>Shortcut: Just use this docker image</h2>
<p>It's based on Ubuntu 16.04 and comes with all the required dependencies:</p>
<pre><code>$ docker run --privileged -it japaric/copper:2016-05-10
# Or use a newer tag. See https://hub.docker.com/r/japaric/copper/tags
</code></pre>
<p>Alternatively, instead of using this docker image, you can ...</p>
<h2>Install the tools on your system</h2>
<p>On most Linux distributions, most of the required tools can be installed via the package manager.
The actual command that you need to call will depend on your Linux distribution. But, here's the one
for Ubuntu:</p>
<pre><code>$ sudo apt-get install gcc-arm-none-eabi gdb-arm-none-eabi openocd qemu-system-arm
</code></pre>
<p>To install Rust and Cargo, I recommend using <a href="https://www.rustup.rs/">rustup</a>:</p>
<pre><code>$ curl https://sh.rustup.rs -sSf | sh -s -- -y --default-toolchain=nightly
</code></pre>
<p>Or if you already have rustup installed, switch to the nightly channel with:</p>
<pre><code>$ rustup default nightly
</code></pre>
<p>Finally, to install Xargo simply use:</p>
<pre><code>$ cargo install xargo
</code></pre>
<h2>First OpenOCD connection</h2>
<blockquote>
<p><strong>TODO</strong> document STM32VLDISCOVERY quirk</p>
</blockquote>
<p>Even if using the Docker image, it's a good idea to test that OpenOCD works by establishing a
connection between your host system (PC, laptop, etc.) and your dev board. First, you'll have to
physically connect your dev board and your host system via an USB cable. Then, you'll have to use a
command that looks like this:</p>
<pre><code>$ sudo openocd -f board/$BOARD
</code></pre>
<p>if you are using a dev board that has a built-in debugger. Or one like this:</p>
<pre><code>$ sudo openocd -f interface/$INTERFACE -f target/$TARGET
</code></pre>
<p>if you are using an external programmer/debugger. Then, you should get an output like this:</p>
<pre><code>Open On-Chip Debugger 0.9.0 (2015-09-02-10:42)
Licensed under GNU GPL v2
For bug reports, read
http://openocd.org/doc/doxygen/bugs.html
Info : The selected transport took over low-level target control. The results might differ
compared to plain JTAG/SWD
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
none separate
srst_only separate srst_nogate srst_open_drain connect_deassert_srst
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v1 JTAG v11 API v2 SWIM v0 VID 0x0483 PID 0x3744
Info : using stlink api v2
Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>
<blockquote>
<p><strong>TODO</strong> add troubleshooting instructions for when the <code>openocd</code> command fails.</p>
</blockquote>
<p>The program will block with that output, but it's okay to exit it with <code>Ctrl-C</code> at this time.</p>
<p>As for the actual values of <code>$BOARD</code>/<code>$INTERFACE</code>/<code>$TARGET</code> that you must use, the possible values
are in <code>/usr/share/openocd/scripts</code> (might be a different directory in your Linux distribution):</p>
<pre><code>$ tree /usr/share/openocd/scripts
/usr/share/openocd/scripts
├── (...)
├── board
│   ├── actux3.cfg
│   ├── adapteva_parallella1.cfg
│   └── (...)
├── interface
│   ├── altera-usb-blaster2.cfg
│   ├── altera-usb-blaster.cfg
│   └── (...)
├── target
│   ├── aduc702x.cfg
│   ├── aducm360.cfg
│   └── (...)
└── (...)
</code></pre>
<p>Try something that resembles the name of your hardware. For example, for the STM32VLDISCOVERY I
use:</p>
<pre><code>$ sudo openocd -f board/stm32vldiscovery.cfg
</code></pre>
<p>And for my custom STM32F4-based dev board which uses an external debugger I use:</p>
<pre><code>$ sudo openocd -f interface/stlink-v1.cfg -f target/stm32f4x.cfg
</code></pre>
<h3>(Optional) OpenOCD without <code>sudo</code></h3>
<blockquote>
<p><strong>NOTE</strong> For those using the Docker image. You have to run these commands on the host system,
<em>not</em> from within the container.</p>
</blockquote>
<p>The reason we have to use <code>sudo</code> in the <code>openocd</code> invocations is that we don't have sufficient
permissions to use the USB device. This can be fixed using <code>udev</code> rules.</p>
<p>First let's identify the USB device OpenOCD is using from the output of <code>sudo openocd</code>:</p>
<pre><code>$ sudo openocd
</code></pre>
<pre><code>$ lsusb
(...)
Bus 003 Device 116: ID 0483:3744 STMicroelectronics STLINK Pseudo disk
(...)
</code></pre>
<p>Device number 116 on the bus 3, let's check its permissions:</p>
<pre><code>$ ls -l /dev/bus/usb/003/116
crw-rw-r-- 1 root root 189, 371 May  9 15:39 /dev/bus/usb/003/116
</code></pre>
<p>Only <code>root</code> can read/write from/to it. We'll write an udev rule to change the permissions of this
particular USB device. udev rules are stored in <code>/etc/udev/rules.d</code> as files, let's add a new one:</p>
<pre><code>$ cat /etc/udev/rules.d/99-openocd.rules
# STLINKv1
ATTRS{idVendor}==&quot;0483&quot;, ATTRS{idProduct}==&quot;3744&quot;, GROUP=&quot;users&quot;
</code></pre>
<p>This udev rule changes the group of the USB device to <code>users</code>.</p>
<blockquote>
<p><strong>NOTE</strong> You <em>can</em> use a group different than <code>users</code>. <strong>But</strong>, if you are using a Docker
container, it's very likely that the id of a different group won't match between the host system
and the container -- in that case you still won't have enough permissions to use the USB device!.</p>
</blockquote>
<blockquote>
<p><strong>NOTE</strong> For more details about the udev rules see <a href="http://linux.die.net/man/7/udev">man 7 udev</a></p>
</blockquote>
<p>You'll have to change 0483 and 3744 for the vendor and product id of <strong>your</strong> device respectively.
You can get those values from <code>lsusb</code>:</p>
<pre><code>$ lsusb | grep STLINK
Bus 003 Device 116: ID 0483:3744 STMicroelectronics STLINK Pseudo disk
                       ^^^^ ^^^^
</code></pre>
<p>This new rule won't come into effect until you reload all the rules with:</p>
<pre><code>$ sudo udevadm control --reload-rules
</code></pre>
<p>Now, unplug and re-plug the device and you should see the updated permissions:</p>
<pre><code>$ lsusb | grep STLINK
Bus 003 Device 118: ID 0483:3744 STMicroelectronics STLINK Pseudo disk

$ ls -l /dev/bus/usb/003/118
crw-rw-r-- 1 root users 189, 373 May  9 16:00 /dev/bus/usb/003/118
</code></pre>
<p>You should now be able to use your <code>openocd</code> command without <code>sudo</code> <strong>if</strong> your user was already
part of the <code>users</code> group. If your user wasn't in that group, you can add yourself to this group
with this command:</p>
<pre><code>$ sudo usermod -a -G users $(whoami)
</code></pre>
<p>You'll have to re-log for this last command to take effect.</p>
<h1>macOS</h1>
<blockquote>
<p><strong>WARNING</strong> Totally untested. If this does/doesn't work, let me know!</p>
</blockquote>
<blockquote>
<p><strong>TODO</strong> Macports as an alternative to brew?</p>
</blockquote>
<blockquote>
<p><strong>TODO</strong> From which fork should we get the <code>arm-none-eabi-*</code> packages? AFAICT, they are not in the
original brew repo.</p>
</blockquote>
<p>You can install most of the required tools using <code>brew</code>:</p>
<pre><code>$ brew install arm-none-eabi-gcc arm-none-eabi-gdb openocd qemu
</code></pre>
<p>To install Rust and Cargo, I recommend using <a href="https://www.rustup.rs/">rustup</a>:</p>
<pre><code>$ curl https://sh.rustup.rs -sSf | sh -s -- -y --default-toolchain=nightly
</code></pre>
<p>Or if you already have rustup installed, switch to the nightly channel with:</p>
<pre><code>$ rustup default nightly
</code></pre>
<p>Finally, to install Xargo simply use:</p>
<pre><code>$ cargo install xargo
</code></pre>
<h2>First OpenOCD connection</h2>
<blockquote>
<p><strong>TODO</strong> Empty section <code>:-)</code>, but most of this stuff looks like the <a href="/linux.html#First%20OpenOCD%20connection">Linux</a> version.</p>
</blockquote>
<blockquote>
<p><strong>TODO</strong> Any permission problems on Mac? i.e. Do we actually need to use <code>sudo</code>?</p>
</blockquote>
<h1>Windows</h1>
<blockquote>
<p><strong>TODO</strong> Coming Soon <code>:-)</code></p>
</blockquote>
<h1>First program</h1>
<p>In this chapter we'll write our first program! Although the program is going to be relatively
uninteresting -- it just allocates some variables on the stack. It will help us:</p>
<ul>
<li>Verify that the development environment is correctly set up.</li>
<li>Get familiar with the several tools that make up the development environment.</li>
<li>Learn about the device-specific pieces required for cross compilation.</li>
</ul>
<p>We'll first cross compile this program for the <a href="http://www.ti.com/product/LM3S6965">LM3S6965</a> microcontroller and then run it under
QEMU. After we verify that it works correctly, we'll run the program on real hardware.</p>
<h1>Build &amp; inspect</h1>
<p>Let's start by creating a new Cargo project:</p>
<pre><code>$ cargo new --bin app &amp;&amp; cd $_
</code></pre>
<p>And then add these files to the project:</p>
<ul>
<li><a href="./first/layout.ld">layout.ld</a> - a &quot;linker script&quot;</li>
<li><a href="./first/cortex-m3.json">cortex-m3.json</a> - a &quot;target specification file&quot;</li>
<li><a href="./first/main.rs">src/main.rs</a></li>
</ul>
<p>I'll explain what these two first files are for in a later section. It's not important to know what
they do <em>right now</em>.</p>
<p>Your project directory should look like this:</p>
<pre><code>$ tree .
</code></pre>
<pre><code>.
├── Cargo.toml
├── cortex-m3.json
├── layout.ld
└── src
    └── main.rs
</code></pre>
<p>For convenience, <code>src/main.rs</code> is replicated here:</p>
<pre><code class="language-rust">#![feature(lang_items)]

// We won't use the usual `main` function. We are going to use a different &quot;entry point&quot;.
#![no_main]

// We won't use the standard library because it requires OS abstractions like threads and files and
// those are not available in this platform.
#![no_std]

// Conceptually, this is our program &quot;entry point&quot;. It's the first thing the microcontroller will
// execute when it (re)boots. (As far as the linker is concerned the entry point must be named
// `start` (by default; it can have a different name). That's why this function is `pub`lic, named
// `start` and is marked as `#[no_mangle]`.)
//
// Returning from this function is undefined because there is nothing to return to! To statically
// forbid returning from this function, we mark it as divergent, hence the `fn() -&gt; !` signature.
#[no_mangle]
pub fn start() -&gt; ! {
    // Our first program initializes some variables on the stack and does nothing more. Yay!
    let x = 42;
    let y = x;

    // We can't return from this function so we just spin endlessly here.
    loop {}
}

// Ignore this part for now :-). It will covered in a later section.
mod vector_table {
    #[link_section = &quot;.reset&quot;]
    static RESET: fn() -&gt; ! = ::start;
}

// Finally, we need to define some &quot;lang items&quot; we are _not_ going to use, but that `rustc` demands
// anyway. As we are not going to use the functionality they provide (panic/unwinding) we can left
// their definitions empty.
mod lang_items {
    #[lang = &quot;panic_fmt&quot;]
    fn panic_fmt() {}

    #[lang = &quot;eh_personality&quot;]
    fn eh_personality() {}
}
</code></pre>
<p>If you have written a native Rust program before, this shouldn't look that different. It's just as
if our &quot;<code>main</code>&quot; function, which in this case is named <code>start</code>, has a different signature.</p>
<p>Now build the project:</p>
<pre><code>$ xargo build --target cortex-m3
</code></pre>
<pre><code>   Compiling app v0.1.0
</code></pre>
<blockquote>
<p><strong>NOTE</strong> Do <strong>not</strong> build the project in release mode!</p>
</blockquote>
<h2>Trust, but verify</h2>
<p>The project appeared to build fine, but it's always a good idea to inspect the executable. We are
going to look at three things:</p>
<h3>Memory layout</h3>
<p>First, you have to appreciate the fact that, during its execution, everything in a program resides
in memory and has an associated memory address. Now, everything that's <em>statically allocated</em>, like
functions and static variables, gets assigned an address at compile time. Whereas, everything else,
like local/stack variables and &quot;heap&quot; allocated variables, gets assigned an address at runtime.</p>
<p>We can observe the addresses of statically allocated stuff using <code>objdump</code>. Let's check our
executable:</p>
<pre><code># with
$ arm-none-eabi-objdump --demangle --disassemble-all target/cortex-m3/debug/app
# or with the equivalent
$ arm-none-eabi-objdump -CD target/cortex-m3/debug/app
</code></pre>
<pre><code>target/cortex-m3/debug/app:     file format elf32-littlearm


Disassembly of section .vector_table:

00000000 &lt;app::vector_table::RESET::ha7f0c0bde3147d64-0x4&gt;:
   0:   20010000    andcs   r0, r1, r0

00000004 &lt;app::vector_table::RESET::ha7f0c0bde3147d64&gt;:
   4:   00000009    andeq   r0, r0, r9

Disassembly of section .text:

00000008 &lt;start&gt;:
   8:   b082        sub sp, #8
   a:   202a        movs    r0, #42 ; 0x2a
   c:   9001        str r0, [sp, #4]
   e:   9000        str r0, [sp, #0]
  10:   e7ff        b.n 12 &lt;start+0xa&gt;
  12:   e7fe        b.n 12 &lt;start+0xa&gt;

(...)
</code></pre>
<p>Let me highlight the important bits of the output:</p>
<pre><code>
00000000
   0:   20010000

00000004
   4:   00000009

00000008 &lt;start&gt;:
   8:               sub sp, #8
   a:               movs    r0, #42 ; 0x2a
   c:               str r0, [sp, #4]
   e:               str r0, [sp, #0]
  10:               b.n 12 &lt;start+0xa&gt;
  12:               b.n 12 &lt;start+0xa&gt;
</code></pre>
<p>Now let's read the output section by section:</p>
<pre><code>00000000
   0:   20010000
</code></pre>
<p>&quot;The memory at address <code>0x0</code> holds the (<code>u32</code>) value <code>0x2001_0000</code>&quot;. When the program starts its
execution, that part of the memory will be already initialized to that value.</p>
<pre><code>00000004
   4:   00000009
</code></pre>
<p>Likewise, &quot;the memory at <code>0x4</code> holds the  (<code>u32</code>) value <code>0x9</code>&quot;.</p>
<pre><code>00000008 &lt;start&gt;:
   8:               sub sp, #8
   a:               movs    r0, #42 ; 0x2a
   c:               str r0, [sp, #4]
   e:               str r0, [sp, #0]
  10:               b.n 12 &lt;start+0xa&gt;
  12:               b.n 12 &lt;start+0xa&gt;
</code></pre>
<p>Finally, &quot;the <code>start</code> function resides at address <code>0x8</code>&quot;. The lines, like <code>sub sp, #8</code>, below
<code>&lt;start&gt;</code> are the instructions that make up the function. When the processor executes this function,
it will execute each one of these instructions.</p>
<p>But, why are these addresses/values important? During boot up, the microcontroller reads the memory
section at <code>0x0..0x8</code> and uses those  values to perform the boot process. In other words, the values
in that memory section have an special meaning to the boot process. In a <a href="details/boot.html">later section</a>, I'll
explain what those values mean and how they are used in the boot process. For now, it's okay to just
confirm that the memory at <code>0x0..0x8</code> is initialized.</p>
<h3>Program size</h3>
<p>Microcontrollers are memory constrained devices. It's important to keep an eye on the size of our
programs to make sure they don't exceed the memory capacity of our device. We'll use the <code>size</code>
command to do that:</p>
<pre><code>$ arm-none-eabi-size target/cortex-m3/debug/app
</code></pre>
<pre><code>   text    data     bss     dec     hex filename
     20       0       0      20      14 target/cortex-m3/debug/app
</code></pre>
<p>The output mentions three different memory <em>sections</em>:</p>
<ul>
<li>The <code>text</code> section contains the &quot;program code&quot;, i.e. all the instructions that the processor will
execute when the program is executed. Functions go in this section. This section also stores
constants like strings. <code>static CONSTANT: &amp;'static str = &quot;Hello, world!&quot;</code>is an example of a
constant.</li>
<li><code>data</code> holds static variables that have an initial value, for example <code>static mut X: i32 = 42</code>.</li>
<li>On the contrary, <code>bss</code> holds &quot;uninitialized&quot; static variables. Because of C heritage, here
&quot;uninitialized&quot; actually means <em>zeroed</em>. For example, <code>static mut ZEROS: [u8; 4] = [0; 4]</code> would
go in this section.</li>
</ul>
<p><code>dec</code> is just the sum of these three sections and <code>hex</code> is the hexadecimal representation of <code>dec</code>.</p>
<p>Our program size is just 20 bytes big! Microcontrollers usually have memory capacities in the order
of a few KiB up to hundreds of KiB. In particular, the LM3S6965 microcontroller, which we are going
to emulate, has 256KiB of (Flash) memory. So, no problem here; this program will fit in the device
memory.</p>
<blockquote>
<p><strong>NOTE</strong> KiB = <a href="https://en.wikipedia.org/wiki/Kibibyte">Kibibyte</a> = 1024 bytes</p>
</blockquote>
<h3>Entry point</h3>
<p>To work properly, tools like <code>gdb</code> and <code>qemu</code> need to be informed about the program entry point,
which is where the program starts its execution.</p>
<p>We can check our program entry point using the <code>readelf</code> command:</p>
<pre><code>$ arm-none-eabi-readelf -h target/cortex-m3/debug/app
</code></pre>
<pre><code>ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           ARM
  Version:                           0x1
  Entry point address:               0x8
  Start of program headers:          52 (bytes into file)
  Start of section headers:          67748 (bytes into file)
  Flags:                             0x5000202, has entry point, Version5 EABI, soft-float ABI
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         16
  Section header string table index: 13
</code></pre>
<p>There you can see that <code>0x8</code> is the entry point address. From the previous <code>objdump</code> output, you
know that <code>0x8</code> is the address of the <code>start</code> function. This means that the entry point have been
correctly declared.</p>
<h1>Run the program under QEMU</h1>
<p>Now that we have an executable in our hands, it's time to test it under an emulator! You may be
wondering &quot;how are we going to do that?&quot; since the program doesn't do any I/O. Well, instead of
expecting the program to output something to the terminal (which won't happen), we are going to
&quot;hook&quot; a debugger to the emulator, execute the program &quot;statement by statement&quot; and verify that the
emulated memory changes as the program executes. Sounds fun? You bet it is.</p>
<p>Let's start! The first thing we have to do is load our binary in the emulator with this command:</p>
<pre><code>$ qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -gdb tcp::3333 -S -nographic -monitor null \
                  -serial null -kernel target/cortex-m3/debug/app
</code></pre>
<p>So many arguments! Let's explain why all those are there for:</p>
<ul>
<li><code>qemu-system-arm</code> this is a QEMU variant that can emulate an ARM processor in system mode
emulation.</li>
<li><code>-machine lm3s6965evb</code> this is the dev board we are going to emulate: the <a href="http://www.ti.com/lit/ug/spmu029a/spmu029a.pdf">LM3S6965EVB</a>.</li>
<li><code>-cpu cortex-m3</code> this is the CPU to emulate, it must match the CPU of the emulated <code>machine</code>.</li>
<li><code>-gdb tcp::3333</code> tells the emulator to expect a gdb connection on port <code>3333</code>, we need this to
control the execution of the emulated program under gdb.</li>
<li><code>-S</code> &quot;do not immediately start the CPU&quot;. This tells the emulator to load the program but don't
immediately execute it, otherwise by the time you attach <code>gdb</code> your program may have already
terminated!</li>
<li><code>-nographic</code>, <code>-monitor null</code> we don't need anything graphic related</li>
<li><code>-serial null</code> we are not going to use the serial console this time</li>
<li><code>-kernel target/cortex-m3/debug/app</code> use our binary directly as the &quot;kernel&quot; which is the first
thing the emulator executes.</li>
</ul>
<p>This command will block; just leave it running for now.</p>
<p>Next we hook a debugger to the emulator we just started. In another terminal, type:</p>
<pre><code>$ arm-none-eabi-gdb target/cortex-m3/debug/app
</code></pre>
<blockquote>
<p><strong>NOTE</strong> You can use <code>lldb</code> instead of <code>gdb</code> but you won't be able to use the same commands I have
used here, because <code>lldb</code> uses different commands to expose the same functionality as <code>gdb</code>.
<a href="http://lldb.llvm.org/lldb-gdb.html">This page</a> will help you map <code>gdb</code> commands to <code>lldb</code>'s and vice versa.</p>
</blockquote>
<p>Under this <code>gdb</code> session, enter the following command to connect to the emulator:</p>
<pre><code>(gdb) target remote :3333
</code></pre>
<p>You should see an output like this:</p>
<pre><code>Remote debugging using :3333
app::start () at src/main.rs:6
6       pub fn start() -&gt; ! {
</code></pre>
<p>The emulator is <em>halted</em> and currently at the program entry point: <code>start</code>. You can now execute the
program statement by statement using the <code>step</code> command:</p>
<pre><code>(gdb) step
7           let x = 42
(gdb) step
8           let y = x
</code></pre>
<p>At this point the statement <code>let x = 42</code> has been executed but the statement <code>let y = x</code> has not, so
<code>x</code> is initialized but <code>y</code> is not. Let's inspect both variables by <code>print</code>ing their addresses and
values.</p>
<pre><code>(gdb) print x
$1 = 42
(gdb) print &amp;x
$2 = (i32 *) 0x2000fffc
(gdb) print y
$3 = 0
(gdb) print &amp;y
$4 = (i32 *) 0x2000fff8
</code></pre>
<p>A few things to note:</p>
<ul>
<li>Both <code>x</code> and <code>y</code> live in the &quot;stack&quot;. That's why they have contiguous addresses.</li>
<li><code>y</code>, which was declared/initialized after <code>x</code>, has a smaller address than <code>x</code>. The reason is that
the stack grows downwards (toward smaller addresses). If you keep creating stack variables, you'll
see their addresses get smaller and smaller.</li>
<li><code>y</code> which is currently uninitialized holds the value <code>0</code> -- this is a QEMU simplification. On real
hardware you will observe that uninitialized variables hold random values. Of course, (safe) Rust
won't actually let you <em>use</em> uninitialized variables but you can peek at them using <code>gdb</code>.</li>
</ul>
<p>Back to the debugger. If you step again, you should see that <code>y</code> is now initialized:</p>
<pre><code>(gdb) step
10          loop {}
(gdb) print y
$5 = 42
</code></pre>
<p>The emulator is about to execute an endless loop. If you call <code>step</code> again, <code>gdb</code> will get stuck in
the loop and hang. Instead, call <code>stepi</code> to advance <em>one instruction</em> rather than one statement.</p>
<pre><code>(gdb) stepi
0x00000012      10          loop {}
(gdb) stepi
0x00000012      10          loop {}
</code></pre>
<p>Congrats, you are now stuck in an endless loop!</p>
<p>There is not much left to do in this emulation. But, before you terminate the <code>gdb</code> session and exit
the emulator ...</p>
<h2>Homework</h2>
<p><code>gdb</code> has an <a href="http://www.delorie.com/gnu/docs/gdb/gdb_56.html">&quot;examine&quot;</a> command that let's you inspect the contents of memory at a certain address.
Try the following command:</p>
<pre><code>(gdb) x/3 start
</code></pre>
<p>Compare the output of that command with the output of the command: <code>arm-none-eabi-objdump -Cd target/cortex-m3/debug/app</code>. Are the outputs related somehow? Elaborate.</p>
<h1>Nitty-gritty details</h1>
<blockquote>
<p>My program works! I have no idea why ...</p>
</blockquote>
<p>Great! We wrote a program that worked in the emulator. But I omitted some important details to
simplify things, so we could focus our attention on the tooling. In particular, I didn't tell you
that our Cargo project generates binaries that only work on the LM3S6965! It's time to take a step
back and understand all the pieces involved. In particular:</p>
<ul>
<li>What's the role of those two extra files, <code>cortex-m3.json</code> and <code>layout.ld</code>, that we added to the
Cargo project?</li>
<li>What was the <code>vector_table</code> module in <code>src/main.rs</code> for?</li>
</ul>
<p>Once you understand that, you'll be able to write programs for <strong>any</strong> Cortex-M microcontroller.</p>
<h1>Target specification</h1>
<p>In this section, we explain what the mysterious <code>cortex-m3.json</code> file is!</p>
<p>Building a Rust program for a Cortex-M microcontroller involves cross compiling. Cross compilation
is the process of building a binary that will run on a <strong>target</strong> device/system that's different
from the <strong>host</strong> device/system where the binary was produced. In our case, the target is the
Cortex-M microcontroller and the host is your laptop or your PC.</p>
<p>Out of the box, <code>rustc</code>, and therefore Cargo, can cross compile for a bunch of different targets
using the <code>--target</code> flag:</p>
<pre><code>$ rustc -V
</code></pre>
<pre><code>rustc 1.11.0-nightly (ad7fe6521 2016-06-23)
</code></pre>
<pre><code>$ rustc --print target-list | column -c 100
</code></pre>
<pre><code>aarch64-apple-ios               i686-linux-android              x86_64-apple-darwin
aarch64-linux-android           i686-pc-windows-gnu             x86_64-apple-ios
aarch64-unknown-linux-gnu       i686-pc-windows-msvc            x86_64-pc-windows-gnu
arm-linux-androideabi           i686-unknown-dragonfly          x86_64-pc-windows-msvc
arm-unknown-linux-gnueabi       i686-unknown-freebsd            x86_64-rumprun-netbsd
arm-unknown-linux-gnueabihf     i686-unknown-linux-gnu          x86_64-sun-solaris
armv7-apple-ios                 i686-unknown-linux-musl         x86_64-unknown-bitrig
armv7-linux-androideabi         le32-unknown-nacl               x86_64-unknown-dragonfly
armv7-unknown-linux-gnueabihf   mips-unknown-linux-gnu          x86_64-unknown-freebsd
armv7s-apple-ios                mips-unknown-linux-musl         x86_64-unknown-linux-gnu
asmjs-unknown-emscripten        mipsel-unknown-linux-gnu        x86_64-unknown-linux-musl
i386-apple-ios                  mipsel-unknown-linux-musl       x86_64-unknown-netbsd
i586-pc-windows-msvc            powerpc-unknown-linux-gnu       x86_64-unknown-openbsd
i586-unknown-linux-gnu          powerpc64-unknown-linux-gnu
i686-apple-darwin               powerpc64le-unknown-linux-gnu
</code></pre>
<p>Unfortunately, Cortex-M microcontrollers are not in this list. This is not a problem though, because
we can teach <code>rustc</code> about new targets using target specification files. A target specification
file is a JSON file that describes the characteristics of the target: its architecture, its OS, etc.
Currently, documentation about these files is scrambled in the compiler source code. These are the
relevant documentation bits:</p>
<ul>
<li><a href="https://github.com/rust-lang/rust/blob/1ab87b65a220a933dc9d171ef0fd865ddd88fe89/src/librustc_back/target/mod.rs#L11-L45">rustc_back::target</a></li>
<li><a href="https://github.com/rust-lang/rust/blob/1ab87b65a220a933dc9d171ef0fd865ddd88fe89/src/librustc_back/target/mod.rs#L151-L171">rustc_back::target::Target</a></li>
<li><a href="https://github.com/rust-lang/rust/blob/1ab87b65a220a933dc9d171ef0fd865ddd88fe89/src/librustc_back/target/mod.rs#L178-L299">rustc_back::target::TargetOptions</a></li>
</ul>
<blockquote>
<p><strong>ATTENTION</strong> These links don't point to the latest revision of the compiler source!</p>
</blockquote>
<p>In a <a href="./first/build.html">previous section</a>, I gave you a target specification file: the <code>cortex-m3.json</code>, which
you used to cross compile for the LM3S6965. That file can be used to cross compile to any micro that
contains a Cortex-M3 processor. But, if you want to cross compile for a microcontroller that has a
different processor, you are going to need a different target specification file.</p>
<p>The list below is a collection of target specification files for all the existing Cortex-M
processors and their most common variants:</p>
<ul>
<li><a href="./target/cortex-m0.json">cortex-m0</a>. Cortex-M0.</li>
<li><a href="./target/cortex-m0plus.json">cortex-m0plus</a>. Cortex-M0+.</li>
<li><a href="./target/cortex-m1.json">cortex-m1</a>. Cortex-M1.</li>
<li><a href="./target/cortex-m3.json">cortex-m3</a>. Cortex-M3.</li>
<li><a href="./target/cortex-m4.json">cortex-m4</a>. Cortex-M4 without a <a href="https://en.wikipedia.org/wiki/Floating-point_unit">Floating Point Unit</a> (FPU).</li>
<li><a href="./target/cortex-m4f.json">cortex-m4f</a>. Cortex-M4 with a FPU. Supports single precision FP
instructions (e.g. <code>vadd.f32</code>).</li>
<li><a href="./target/cortex-m7.json">cortex-m7</a>. Cortex-M7 without a FPU.</li>
<li><a href="./target/cortex-m7f.json">cortex-m7f</a>. Cortex-M7 with a FPU. Supports both single and double
precision FP instructions.</li>
<li><a href="./target/cortex-m7f-sp.json">cortex-m7f-sp</a>. Cortex-M7 with a FPU. Only supports single precision
FP instructions.</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> All these targets use the soft float ABI</p>
</blockquote>
<p>These files should cover most of your cross compilation needs. To figure out which file you need to
use for your microcontroller, first check which processor your micro has and whether it has a FPU or
not, then choose a file from the above list based on its description.</p>
<p>If you want to know why these files have the contents they have, check <a href="https://github.com/japaric/rfcs/blob/cortex-m-targets/text/0000-cortex-m-targets.md#target-specifications">this RFC</a>. The information
therein should be useful if you want to tweak these target specification files for some reason.</p>
<h1>Boot process</h1>
<p>In this section, we'll learn what the microcontroller does right after it's powered.</p>
<h2>Memory</h2>
<p>But before that, we have to talk a little about the different types of memory available in a
microcontroller. Cortex-M microcontrollers have at least two different types of memory available to
them: Flash memory and Random Access Memory (RAM).</p>
<p>Flash memory is non-volatile and it's used to store the <code>text</code> section of our program, i.e.
functions and constants. Because this memory is non-volatile, our program will persist in memory
even if the microcontroller is powered off.</p>
<p>RAM, on the other hand, is volatile and it's used to store the <a href="https://en.wikipedia.org/wiki/Call_stack">call stack</a>, the <a href="https://en.wikipedia.org/wiki/Memory_management#HEAP">heap</a> and static
variables. Because RAM is volatile, its contents are lost when the microcontroller is powered off.
Also, when the microcontroller have just been powered on, its RAM is filled with random values.</p>
<p>These two different memories can be accessed by the processor through the same address space. For
instance, the LM3S6965 has the following memory specifications:</p>
<ul>
<li>256 KiB of flash memory. The flash memory region starts at address <code>0x0</code> and ends at address
<code>0x40000</code>.</li>
<li>64 KiB of RAM. The RAM region starts at address <code>0x2000_0000</code> and ends at address <code>0x2001_0000</code>.</li>
</ul>
<h3>Vector table</h3>
<p>On Cortex-M microcontrollers, the beginning of the flash memory holds a data structure known as the
&quot;vector table&quot;. The values stored in the vector table are used in different hardware processes like
the boot process.</p>
<p>The vector table is, effectively, an array of pointers and each of its elements is used for a
different purpose. The vector table is fully documented <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0552a/BABIFJFG.html">here</a>. But, right now, we are only
interested in its first two elements:</p>
<ol>
<li>At <code>0x0</code>: the initial value of the stack pointer.</li>
</ol>
<p>The stack pointer is a register used to track the top of the call stack. The initial value
determines where in memory the call stack will be initialized. As per the <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042f/IHI0042F_aapcs.pdf#page=16&amp;zoom=auto,52,151">AAPCS</a> (ARM
Architecture Procedure Call Standard), the call stack grows downwards (towards smaller addresses).
That's why the initial value of the stack pointer is usually set to the largest valid address of the
RAM region.</p>
<ol start="2">
<li>At <code>0x4</code>: the reset vector</li>
</ol>
<p>A &quot;vector&quot; is a pointer to a &quot;handler&quot; and a &quot;handler&quot; is just another name for a function.
Therefore, the reset vector is a (function) pointer to the reset handler. The reset handler gets
called, through the reset vector, whenever a reset occurs and during the boot process.</p>
<h2>Putting everything together</h2>
<p>Here's what happens during the boot process or whenever the microcontroller is reset:</p>
<ul>
<li><code>SP = *(0x0 as *const usize)</code>. The stack pointer, which is a register, is initialized to the value
stored at address <code>0x0</code>.</li>
<li><code>(*(0x4 as *const fn()))()</code>. The reset handler gets called through the reset vector.</li>
</ul>
<h2>The takeaway</h2>
<p>What you should remember from all this is that the programs you write for Cortex-M microcontrollers
must comply with a <strong>specific memory layout</strong>. In particular, the memory section at address <code>0x0</code>,
the vector table, must be properly initialized or your microcontroller won't boot! In the next
section, we'll go over the boot process again using the LM3S6965 as an example.</p>
<h1>Linker script</h1>
<p>As we saw in the previous section, our program must comply with a specific memory layout for the
microcontroller to work properly (otherwise it won't boot!).</p>
<p>The linker is what ultimately determines the memory layout of our program. To some extend, we can
control the linker, and therefore the memory layout of our program, using a file called linker
script.</p>
<p>For our first program, I gave you the linker script <code>layout.ld</code>. In this section, I'll explain its
contents.</p>
<h2>Terminology</h2>
<p>First, let's define some terms you'll often hear when dealing with linker scripts.</p>
<h3>Linking</h3>
<p>The process of producing a binary from a Rust source code involves two steps (or several more if you
peek inside <code>rustc</code>'s pipeline): compiling and linking. Compiling is the action of producing an
intermediate file known as &quot;object file&quot; from the source code. In Rust, the minimal compilation unit
is the crate which can be a single <code>.rs</code> or a collection of them. Each crate gets compiled to
an object file (actually to an <code>.rlib</code> which is an object file plus &quot;metadata&quot;). To produce the
final binary/executable, the compiled crates get &quot;merged&quot; together; this process is known as
linking.</p>
<h3>Symbol</h3>
<p>A symbol is either a function or a static variable. Each symbol has a name, a start address and
occupies some space memory. For example, our program entry point is a symbol with name <code>start</code> and
address <code>0x8</code> and occupies 12 bytes (6 16-bit instructions) in memory.</p>
<h3>Section</h3>
<p>A section is a collection of symbols stored in contiguous memory. Other way to think about this is
that symbols are <em>organized</em> in sections. In a bit we'll see why it's advantageous to group symbols
into sections.</p>
<p>An example of a section: In our program, the vector table can be thought of as a section composed of
two symbols: the first is the initial SP value with address <code>0x0</code>, and the second symbol is the
reset vector with address <code>0x4</code>.</p>
<h3>Region</h3>
<p>A (memory) region is a span of memory that's described using a start address and a length (in
bytes). For example, the LM3S6965 has two memory regions: Its flash memory region which starts at
address <code>0x0</code> and has a size of 256 KiB, and its RAM region which starts at address <code>0x2000_0000</code> and
has a size of 64 KiB.</p>
<h3>Object files</h3>
<p>The linker takes as input one or more object files and outputs a single object file. In this book,
we'll be exclusively working with object files in the ELF format. ELF also happens to be the
format Linux executables use, but there exist other formats like Mach-O (macOS) and COFF (Windows).</p>
<h2><code>layout.ld</code></h2>
<p>Instead of explaining the linker script syntax (which is documented <a href="https://sourceware.org/binutils/docs/ld/Scripts.html">elsewhere</a>), I'm going to
focus on explaining the contents of the <code>layout.ld</code> file and how this file relates to the boot
process we covered in the previous section.</p>
<p>For convenience, here's the full linker script.</p>
<pre><code>MEMORY
{
  FLASH : ORIGIN = 0x00000000, LENGTH = 256K
  RAM  : ORIGIN = 0x20000000, LENGTH = 64K
}

SECTIONS
{
  .vector_table ORIGIN(FLASH) :
  {
    LONG(ORIGIN(RAM) + LENGTH(RAM))
    KEEP(*(.reset))
  } &gt; FLASH

  .text :
  {
    *(.text*)
  } &gt; FLASH

  /DISCARD/ :
  {
    *(.ARM.exidx*)
    *(.note.gnu.build-id*)
  }
}
</code></pre>
<p>Let's go over it block by block</p>
<h3>MEMORY</h3>
<pre><code>MEMORY
{
  FLASH : ORIGIN = 0x00000000, LENGTH = 256K
  RAM  : ORIGIN = 0x20000000, LENGTH = 64K
}
</code></pre>
<blockquote>
<p><strong>NOTE</strong> In linker scripts, <code>K</code> means <code>1024</code> (not <code>1000</code>!) , <code>M</code> means <code>1048576</code> (i.e. <code>1024 * 1024</code>) and so on.</p>
</blockquote>
<p>The <code>MEMORY</code> block declares two memory regions: one named FLASH and the other named RAM. These
regions represent the flash memory and RAM regions of the LM3S6965.</p>
<h3>SECTIONS</h3>
<pre><code>SECTIONS
{
  /* .. */
}
</code></pre>
<p>The <code>SECTIONS</code> block declares sections and assigns each section to a memory region. It's important
to assign each and every section to a memory region, otherwise you'll get weird &quot;overlap&quot; linker
errors.</p>
<h4>.vector_table</h4>
<pre><code>  .vector_table ORIGIN(FLASH) :
  {
    LONG(ORIGIN(RAM) + LENGTH(RAM))
    KEEP(*(.reset))
  } &gt; FLASH
</code></pre>
<p>This section represents the vector table which, as I've mentioned before, must follow a specific
layout:</p>
<ol>
<li>It must be located at address <code>0x0</code>.</li>
<li>Its first element is: the initial SP value.</li>
<li>Its second element is: the reset vector.</li>
</ol>
<p>This is how we meet these constraints in the linker script:</p>
<ol>
<li><code>.vector_table ORIGIN(FLASH) :</code>. &quot;Place the <code>vector_table</code> section at address <code>ORIGIN(FLASH)</code>
(i.e. <code>0x0</code>)&quot;. And, <code>} &gt; FLASH</code>. &quot;Place the <code>vector_table</code> section in the FLASH region&quot;.</li>
<li><code>LONG(ORIGIN(RAM) + LENGTH(RAM))</code>. &quot;The first symbol in the <code>vector_table</code> section is an
<em>anonymous</em> symbol with value <code>0x2001_0000</code>&quot;. We are using the highest valid RAM address as the
initial SP value and the expression <code>LONG(ORIGIN(RAM) + LENGTH(RAM))</code> evaluates to that (refer
to the <code>MEMORY</code> block for the values of <code>ORIGIN(RAM)</code> and <code>LENGTH(RAM)</code>).</li>
<li><code>KEEP(*(.reset))</code>. &quot;Place all the <code>reset</code> sections found in the input files right after the
anonymous symbol we defined before&quot;. On its own, this is not enough. What we really want to place
here is    a function pointer not a section. The following Rust code from <code>src/main.rs</code> completes
the operation:</li>
</ol>
<pre><code class="language-rust">mod vector_table {
    #[link_section = &quot;.reset&quot;]
    static RESET: fn() -&gt; ! = ::start;
}
</code></pre>
<p>This Rust code places a pointer to the <code>start</code> function (the reset vector!) in a section named
<code>reset</code>. <code>src/main.rs</code> then gets compiled to an object file that has a <code>reset</code> section with the
function pointer in it. The linker will take that <code>reset</code> section and place it in the output
executable right after the anonymous &quot;initial SP value&quot; symbol.</p>
<blockquote>
<p><strong>NOTE</strong> &quot;Place <strong>all</strong> the <code>reset</code> sections ...&quot;. This may become a problem if we start linking
more crates and one those crates also happens to contain its own <code>reset</code> section. In the future,
we'll add protective measures against this scenario.</p>
</blockquote>
<h4>.text</h4>
<pre><code>  .text :
  {
    *(.text*)
  } &gt; FLASH
</code></pre>
<p>As I mentioned before, the <code>text</code> section contains the program code. What this block does is merge
the <code>text</code> sections from all the input files in a big <code>text</code> section and places that merged section
in the FLASH region. The last bit is the most important: the program code must reside in
non-volatile memory, i.e. flash memory.</p>
<h4>/DISCARD/</h4>
<pre><code>  /DISCARD/ :
  {
    *(.ARM.exidx*)
    *(.note.gnu.build-id*)
  }
</code></pre>
<p><code>/DISCARD/</code> is not a real section. Everything in this &quot;special section&quot; gets discarded by the linker
and doesn't make it to the output object. So, why are we discarding these specific symbols?</p>
<ul>
<li><code>.ARM.exidx*</code> These symbols are related to unwinding. Which we aren't using! If we leave these
symbols in, they'll in turn demand other symbols related to unwinding and cause &quot;undefined
reference&quot; linker error.</li>
<li><code>note.gnu.build-id*</code>. These symbols are introduced by <code>gcc</code>, which is the linker we are using. If
not removed, these symbols will try to place themselves at address <code>0x0</code> causing &quot;overlap&quot; linker
errors.</li>
</ul>
<h2>Inspect again</h2>
<p>Let's look again at the <code>objdump</code> output from section <a href="./first/build.html">3.1</a>. We should now be able to understand it
better:</p>
<pre><code>$ arm-none-eabi-objdump -CD target/cortex-m3/debug/app
target/cortex-m3/debug/app:     file format elf32-littlearm


Disassembly of section .vector_table:

00000000 &lt;app::vector_table::RESET::ha7f0c0bde3147d64-0x4&gt;:
   0:   20010000    andcs   r0, r1, r0

00000004 &lt;app::vector_table::RESET::ha7f0c0bde3147d64&gt;:
   4:   00000009    andeq   r0, r0, r9

Disassembly of section .text:

00000008 &lt;start&gt;:
   8:   b082        sub sp, #8
   a:   202a        movs    r0, #42 ; 0x2a
   c:   9001        str r0, [sp, #4]
   e:   9000        str r0, [sp, #0]
  10:   e7ff        b.n 12 &lt;start+0xa&gt;
  12:   e7fe        b.n 12 &lt;start+0xa&gt;
  
(..)
</code></pre>
<p>Let's go over it part by part but in reverse!</p>
<pre><code>Disassembly of section .text:

00000008 &lt;start&gt;:
   8:   b082        sub sp, #8
   a:   202a        movs    r0, #42 ; 0x2a
   c:   9001        str r0, [sp, #4]
   e:   9000        str r0, [sp, #0]
  10:   e7ff        b.n 12 &lt;start+0xa&gt;
  12:   e7fe        b.n 12 &lt;start+0xa&gt;
</code></pre>
<p>The <code>text</code> section is our program code. These are the instructions that the microcontroller will
execute. There's only one symbol in this section: the <code>start</code> function. Note the address of the
<code>start</code> function: <code>0x8</code>; this function is located in the FLASH region / in flash memory.</p>
<pre><code>Disassembly of section .vector_table:

00000000 (..)

00000004 (..)
</code></pre>
<p>The vector table resides at address <code>0x0</code>.</p>
<pre><code>00000000 &lt;app::vector_table::RESET::ha7f0c0bde3147d64-0x4&gt;:
   0:   20010000    andcs   r0, r1, r0
</code></pre>
<p>The first element of the vector table is an &quot;anonymous&quot; symbol (though the linker automatically
generates a name for it, based on the names of nearby symbols) with value <code>0x2001_0000</code>.
<code>0x2001_0000</code> is the highest valid RAM address of the LM3S6965.</p>
<pre><code>00000004 &lt;app::vector_table::RESET::ha7f0c0bde3147d64&gt;:
   4:   00000009    andeq   r0, r0, r9
</code></pre>
<p>The second element of the vector table is the symbol <code>app::vector_table::RESET</code>. This symbol is a
pointer to the <code>start</code> function. Its value is <code>0x9</code>. Wait ... the address of the <code>start</code> function is
<code>0x8</code> not <code>0x9</code>! Did we do something wrong? No. Don't worry, this is correct. What happens here is
that the microcontroller (the processor actually) is operating in THUMB mode and in THUMB mode
function pointers have their Least Significant Bit (LSB) set to 1. So the <code>0x8</code> becomes <code>0x9</code> (<code>0x8 | 0b1</code>).</p>
<h2>Closing comment</h2>
<p>You don't need to commit all this to memory right now -- I know it's a lot to take in. But, yes,
linker scripts are important and we'll be dealing with them again in the future. At that time, feel
free to refer back to this section as a reference. For now, the take home message is:</p>
<ul>
<li>When programming against hardware, your program must follow a device-specific memory layout.</li>
<li>You can use a linker script to adjust your program memory layout to fit those constraints.</li>
</ul>
<h1>Run it on real hardware</h1>
<blockquote>
<p><strong>TODO</strong> Document gotchas. Some dev boards may need to plug/unplug jumpers to enable the built-in
programmer/debugger.</p>
</blockquote>
<p>It's time to test our program on real hardware! We'll use OpenOCD  to <em>flash</em> our program into the
microcontroller and then hook <code>gdb</code> and OpenOCD to debug our program just like we did before.</p>
<blockquote>
<p>Wait, what's flashing?</p>
</blockquote>
<p><em>Flashing</em> means we are going to transfer our program from the host machine (PC, laptop, etc.) to
the target device (the microcontroller). Once flashed, the micro will execute the flashed program
every time it boots or resets.</p>
<blockquote>
<p><strong>ATTENTION!</strong> The flashing instructions here will overwrite the program that's currently stored
in your microcontroller. Make sure that it's either something you are not gonna miss or that's
something you can easily get a copy of.</p>
</blockquote>
<h2>Compile for a different target device</h2>
<p>Unless you happen to have a real LM3S6965EVB board right next to you, the binary we produced in the
previous section won't work for your device. To produce a valid binary for your device, you'll have
to change the cross compilation target from the LM3S6965 to <em>your</em> device and then rebuild the
program.</p>
<p>For the rest of this section, I'll be using the <a href="http://www.st.com/content/st_com/en/products/evaluation-tools/product-evaluation-tools/mcu-eval-tools/stm32-mcu-eval-tools/stm32-mcu-discovery-kits/stm32vldiscovery.html">STM32VLDISCOVERY</a> as the target device.</p>
<h3>Update the linker script</h3>
<p>One of the things that you'll always have to do when changing the cross compilation target is to
update the device-specific parts of the linker script.</p>
<p>The STM32VLDISCOVERY contains a <a href="http://www.st.com/resource/en/datasheet/stm32f100rb.pdf">STM32F100RBT6B</a> micro with 128KiB of flash and 8KiB of RAM. A
peculiarity of STM32 devices is that their flash memory starts at address <code>0x0800_0000</code>.</p>
<p><em>My</em> linker script adjustments look like this (yours will probably look different):</p>
<pre><code class="language-diff"> MEMORY
 {
-  FLASH : ORIGIN = 0x00000000, LENGTH = 256K
-  RAM   : ORIGIN = 0x20000000, LENGTH = 64K
+  FLASH : ORIGIN = 0x08000000, LENGTH = 128K
+  RAM   : ORIGIN = 0x20000000, LENGTH = 8K
 }
</code></pre>
<h3>Change the target specification</h3>
<p>Depending on the micro in your dev board, you may also have to change the <code>rustc</code> target from
<code>cortex-m3</code> to something else. In my case, the STM32F100RBT6B also contains a Cortex-M3 processor so
I don't need to change the argument of the <code>--target</code> flag.</p>
<h2>Build &amp; inspect</h2>
<p>Now that the changes have been committed, we can rebuild the program:</p>
<pre><code>$ xargo build --target $TARGET
</code></pre>
<blockquote>
<p><strong>NOTE</strong> From now on, I'm going to use <code>$TARGET</code>, instead of e.g. <code>cortex-m3</code>, as a placeholder
for the cross compilation target to make sure you don't use the wrong target triple.</p>
</blockquote>
<blockquote>
<p><strong>HEADS UP</strong> Make sure that Cargo actually rebuilds the binary! Cargo doesn't trigger a rebuild
when the linker script changes. So, if the only thing you changed was the linker script and not
the <code>rustc</code> target, then you'll have to <code>cargo clean</code> first and then call <code>build</code>.</p>
</blockquote>
<p>As usual, it's a good idea to inspect the binary with <code>objdump</code> to verify that the vector table is
where expected.</p>
<pre><code>$ arm-none-eabi-objdump -CD target/$TARGET/debug/app
</code></pre>
<pre><code>target/$TARGET/debug/app:     file format elf32-littlearm


Disassembly of section .vector_table:

08000000 &lt;app::vector_table::RESET::ha7f0c0bde3147d64-0x4&gt;:
 8000000:   20002000    andcs   r2, r0, r0

08000004 &lt;app::vector_table::RESET::ha7f0c0bde3147d64&gt;:
 8000004:   08000009    stmdaeq r0, {r0, r3}

Disassembly of section .text:

08000008 &lt;start&gt;:
 8000008:   b082        sub     sp, #8
 800000a:   202a        movs    r0, #42 ; 0x2a
 800000c:   9001        str     r0, [sp, #4]
 800000e:   9000        str     r0, [sp, #0]
 8000010:   e7ff        b.n     8000012 &lt;start+0xa&gt;
 8000012:   e7fe        b.n     8000012 &lt;start+0xa&gt;
</code></pre>
<p>Looks good! The vector table is at <code>0x0800_0000</code> as expected for my device.</p>
<h2>Establishing an OpenOCD connection</h2>
<p>Before we flash the program we have to &quot;open&quot; an OpenOCD connection between the device and the host
machine. You should be already familiar with these steps from the <a href="/de/linux.html#First%20OpenOCD%20connection">development environment</a>
chapter:</p>
<pre><code># Physically connect the dev board to the host machine (probably your laptop), then
$ [sudo] openocd -f board/$BOARD
</code></pre>
<pre><code>(...)
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v1 JTAG v11 API v2 SWIM v0 VID 0x0483 PID 0x3744
Info : using stlink api v2
Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>
<h2>Flash and debug</h2>
<p>We'll use the <code>gdb</code> shell to both flash and debug the program. So, fire up <code>gdb</code>:</p>
<blockquote>
<p><strong>NOTE</strong> You can't use <code>lldb</code> this time <code>:-(</code>. AFAICT, there's no <code>lldb</code> equivalent to the
<code>monitor</code> and <code>load</code> commands provided by <code>gdb</code>. And those commands are required in this section.</p>
</blockquote>
<pre><code>$ arm-none-eabi-gdb target/$TARGET/debug/app
</code></pre>
<p>Next, we need to connect <code>gdb</code> and OpenOCD. The command is the same as the one we used with QEMU:</p>
<pre><code>(gdb) target remote :3333
Remote debugging using :3333
0x00000000 in ?? ()
</code></pre>
<p>You should also see extra output on the OpenOCD terminal but maybe not the exact same output shown
here:</p>
<pre><code class="language-diff"> Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints
+Info : accepting 'gdb' connection on tcp/3333
+Info : device id = 0x10016420
+Info : flash size = 128kbytes
</code></pre>
<p>Now that we are connected to the device via <code>gdb</code>. Let's flash the program using the <code>load</code> command:</p>
<pre><code>(gdb) load
Loading section .vector_table, size 0x8 lma 0x8000000
Loading section .text, size 0xc lma 0x8000008
Start address 0x8000008, load size 20
Transfer rate: 246 bytes/sec, 10 bytes/write.
</code></pre>
<p>You should also see new output on the OpenOCD terminal:</p>
<pre><code class="language-diff"> Info : accepting 'gdb' connection on tcp/3333
 Info : device id = 0x10016420
 Info : flash size = 128kbytes
+stm32f1x.cpu: target state: halted
+target halted due to debug-request, current mode: Thread
+xPSR: 0x01000000 pc: 0x08000008 msp: 0x20002000
+stm32f1x.cpu: target state: halted
+target halted due to breakpoint, current mode: Thread
+xPSR: 0x61000000 pc: 0x2000003a msp: 0x20002000
+stm32f1x.cpu: target state: halted
+target halted due to debug-request, current mode: Thread
+xPSR: 0x01000000 pc: 0x08000008 msp: 0x20002000
</code></pre>
<p>The program is now flashed and the device is halted at the program's entry point, i.e. the <code>start</code>
function. Let's repeat the debug session we used for the previous QEMU run:</p>
<pre><code>(gdb) step
7           let x = 42
(gdb) step
8           let y = x
(gdb) print x
$1 = 42
(gdb) print &amp;x
$2 = (i32 *) 0x20001ffc
(gdb) print y
$3 = -2052926870
(gdb) print/x y
$4 = 0x85a2d26a
(gdb) print &amp;y
$5 = (i32 *) 0x20001ff8
(gdb) step
10          loop {}
(gdb) print y
$5 = 42
</code></pre>
<p>Yay! This time the uninitialized value of <code>y</code> looks more random; I got <code>-2052926870</code> on this run.</p>
<p>While you executed the above commands, you should have seen more output on the OpenOCD terminal.
Each time you stepped over the program, OpenOCD printed the <em>program counter</em> which is the address
of the instruction the processor will execute next.</p>
<pre><code class="language-diff"> xPSR: 0x01000000 pc: 0x08000008 msp: 0x20002000
+Info : halted: PC: 0x0800000a
+Info : halted: PC: 0x0800000c
+Info : halted: PC: 0x0800000e
+Info : halted: PC: 0x08000010
</code></pre>
<p>Here's one more trick for you to try:</p>
<pre><code>(gdb) monitor reset halt
</code></pre>
<p>This will generate the following OpenOCD output:</p>
<pre><code> Info : halted: PC: 0x08000010
+stm32f1x.cpu: target state: halted
+target halted due to debug-request, current mode: Thread
+xPSR: 0x01000000 pc: 0x08000008 msp: 0x20002000
</code></pre>
<p>This will reset your microcontroller (!) and halt your program at the reset handler, i.e. the
<code>start</code> function.</p>
<p>For fun, let's inspect the <code>x</code> and <code>y</code> variables <strong>before</strong> they are initialized:</p>
<pre><code>(gdb) step
7           let x = 42
(gdb) print x
$6 = 42
(gdb) print &amp;x
$7 = (i32 *) 0x20001ffc
(gdb) print y
$8 = 42
(gdb) print &amp;y
$9 = (i32 *) 0x20001ff8
</code></pre>
<p>Surprise! Both variables appear to have been already initialized! Except, that's not the case. What
actually happened is that resetting the microcontroller doesn't affect the RAM (i.e. it doesn't
power it off). Therefore, the RAM still holds the information from the previous run and that's why
<code>x</code> and <code>y</code> hold the value <code>42</code> they were assigned on the <em>previous</em> run of the program.</p>
<p>That's all for this section! You can now close both OpenOCD and <code>gdb</code>. Let's move onto more complex
programs!</p>
<h1>Exceptions: Crashing your micro</h1>
<p>In the previous chapter we wrote a very simple program, built a binary from it, verified that said
binary was well-formed (i.e. that it had a vector table where expected), and even executed it under
an emulator and also on real hardware. Everything went smoothly! However, when developing things are
bound to go awry at some point. In the worst case scenario, one might, by mistake, ask the
microcontroller to perform an operation that it can't handle, like:</p>
<ul>
<li>Reading/writing to a invalid memory address e.g. beyond the limits of the RAM region.</li>
<li>Writing to flash memory using simple assignments (<code>*ptr = value</code>). Flash memory has an elaborate
write mechanism.</li>
<li>Executing an instruction that the microcontroller doesn't support. Like trying to execute a
floating point instruction (e.g. <code>vadd.f32</code>) on a device without a FPU.</li>
</ul>
<p>Under these situations, the processor will raise a <em>hardware exception</em>. When an exception is
raised, the normal flow of our program is <em>interrupted</em> (stopped) and the processor jumps to an
exception <em>handler</em> (recall: handler is just another name for function).</p>
<p>There are several types of exceptions but most of them signify a catastrophic failure and, in real
applications, are usually handled by resetting the system (if bare metal) or by resetting/killing
the faulty process (if running on top of an OS). These catastrophic exceptions should happen rarely
though (if ever) during the execution of a program; hence the name &quot;exception&quot;.</p>
<p>As we are just starting out and we are going to be running our programs under the debugger, we'll
handle all the exceptions the same way: we'll halt the processor and yield control back to the
debugger using the <code>bkpt</code> instruction.</p>
<blockquote>
<p><strong>NOTE</strong> Executing the <code>bkpt</code> instruction when there is no debugger attached to the processor will
make the processor raise an exception!</p>
</blockquote>
<h2>Installing the exception handlers</h2>
<p>As the official ARM <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0552a/BABIFJFG.html">documentation</a> states, the exception vectors (recall: a vector is a pointer to a
handler, i.e. a function pointer) must be stored in the vector table just right after the reset
vector. We'll extend our linker script, <code>layout.ld</code>, to account for this:</p>
<pre><code class="language-diff">   .vector_table ORIGIN(FLASH) :
   {
     LONG(ORIGIN(RAM) + LENGTH(RAM))
     KEEP(*(.reset))
+    KEEP(*(.exceptions))
   } &gt; FLASH
</code></pre>
<p>The change is quite literal: &quot;Place the exceptions (section) right after the reset (section)&quot;.</p>
<p>Now we need to populate this section in our Rust program:</p>
<pre><code class="language-rust">// Add this to `src/main.rs`

#![feature(asm)]

mod exception {
    pub fn handler() {
        unsafe {
            asm!(&quot;bkpt&quot;);
        }

        loop {}
    }
}

mod vector_table {
    #[link_section = &quot;.exceptions&quot;]
    static EXCEPTIONS: [Option&lt;fn() -&gt; !&gt;; 14] = [Some(::exception::handler),  // NMI
                                                  Some(::exception::handler),  // Hard fault
                                                  Some(::exception::handler),  // Memory management fault
                                                  Some(::exception::handler),  // Bus fault
                                                  Some(::exception::handler),  // Usage fault
                                                  None, // Reserved
                                                  None, // Reserved
                                                  None, // Reserved
                                                  None, // Reserved
                                                  Some(::exception::handler),  // SVCall
                                                  None, // Reserved for Debug
                                                  None, // Reserved
                                                  Some(::exception::handler),  // PendSV
                                                  Some(::exception::handler)]; // Systick
}
</code></pre>
<p>Let's go over each section added to our program:</p>
<pre><code class="language-rust">mod exception {
    pub fn handler() -&gt; ! {
        unsafe {
            asm!(&quot;bkpt&quot;);
        }

        loop {}
    }
}
</code></pre>
<p><code>exception::handler</code> is the function that we'll use to handle all the exceptions. This handler uses
the <code>bkpt</code> instruction to trigger a manual breakpoint and then loops endlessly. We mark this
function as divergent to avoid returning from it. &quot;Why?&quot; Because whatever may have caused the
exception could have corrupted the stack or left some value uninitialized so continuing the
execution of our program after an exception would led to unexpected behavior.</p>
<pre><code class="language-rust">mod vector_table {
    #[link_section = &quot;.exceptions&quot;]
    static EXCEPTIONS: [Option&lt;fn() -&gt; !&gt;; 14] = [Some(::exception::handler), // NMI
                                                  Some(::exception::handler), // Hard fault
                                                  Some(::exception::handler), // Memory management fault
                                                  Some(::exception::handler), // Bus fault
                                                  Some(::exception::handler), // Usage fault
                                                  None, // Reserved
                                                  None, // Reserved
                                                  None, // Reserved
                                                  None, // Reserved
                                                  Some(::exception::handler), // SVCall
                                                  None, // Reserved for Debug
                                                  None, // Reserved
                                                  Some(::exception::handler), // PendSV
                                                  Some(::exception::handler)]; // Systick
}
</code></pre>
<p>On the second part, we populate the <code>exceptions</code> section with the addresses of the exception
handlers. The <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0552a/BABIFJFG.html">documentation</a> states that there are 14 exception &quot;slots&quot; right after the reset
handler so we'll place a 14-element array of function pointers in the <code>exceptions</code> section. Some
of the exceptions slots, the ones marked as &quot;Reserved&quot; on the docs, will never be used at runtime;
we'll leave those uninitialized (i.e. zeroed). In Rust, function pointers <code>fn()</code> are non-nullable.
To get nullable function pointers we must wrap the <code>fn()</code>s in an <code>Option</code>, then the <code>None</code> variant
becomes the equivalent of the null pointer.</p>
<h2>Build and inspect</h2>
<p>It's always a good idea to inspect the output binary to check that everything looks as expected:</p>
<pre><code>$ xargo build --target $TARGET
</code></pre>
<pre><code>$ arm-none-eabi-objdump -CD target/$TARGET/debug/app
</code></pre>
<pre><code>target/cortex-m3/debug/app:     file format elf32-littlearm


Disassembly of section .vector_table:

08000000 &lt;app::vector_table::RESET::ha7f0c0bde3147d64-0x4&gt;:
 8000000:   20002000    andcs   r2, r0, r0

08000004 &lt;app::vector_table::RESET::ha7f0c0bde3147d64&gt;:
 8000004:   08000041    stmdaeq r0, {r0, r6}

08000008 &lt;app::vector_table::EXCEPTIONS::h6c345024c0ffa34c&gt;:
 8000008:   08000045    stmdaeq r0, {r0, r2, r6}
 800000c:   08000045    stmdaeq r0, {r0, r2, r6}
 8000010:   08000045    stmdaeq r0, {r0, r2, r6}
 8000014:   08000045    stmdaeq r0, {r0, r2, r6}
 8000018:   08000045    stmdaeq r0, {r0, r2, r6}
    ...
 800002c:   08000045    stmdaeq r0, {r0, r2, r6}
    ...
 8000038:   08000045    stmdaeq r0, {r0, r2, r6}
 800003c:   08000045    stmdaeq r0, {r0, r2, r6}

Disassembly of section .text:

08000040 &lt;start&gt;:
 8000040:   e7ff        b.n 8000042 &lt;start+0x2&gt;
 8000042:   e7fe        b.n 8000042 &lt;start+0x2&gt;

08000044 &lt;app::exception::handler::ha8f05ee13115908a&gt;:
 8000044:   be00        bkpt    0x0000
 8000046:   e7ff        b.n 8000048 &lt;app::exception::handler::ha8f05ee13115908a+0x4&gt;
 8000048:   e7fe        b.n 8000048 &lt;app::exception::handler::ha8f05ee13115908a+0x4&gt;
</code></pre>
<p>The two most relevant things to note: The <code>exception::handler</code> is located at address <code>0x0800_0044</code>.
And, <code>vector_table::EXCEPTIONS</code>, the part of the vector table where the exception handlers reside,
is mainly filled with the THUMB address of <code>exception::handler</code> i.e. <code>0x0800_0045</code>; which is what we
wanted. You will also see a few <code>...</code> under <code>vector_table::EXCEPTIONS</code>, these are the reserved
exceptions slots and they are basically zeroed/uninitialized chunks of memory.</p>
<h2>Let's crash!</h2>
<blockquote>
<p><strong>NOTE</strong> This program won't work on QEMU. AFAICT, raising an exception on a emulated device is
rather hard. For some reason (probably to simplify the implementation), actions that normally
raise an exception on real hardware are allowed in QEMU. <em>shrugs</em></p>
</blockquote>
<p>Let's write a program that raises an exception to test the exception handler. Our program will
attempt to read memory beyond the RAM region. Here is it:</p>
<pre><code class="language-rust">fn start() -&gt; ! {
    unsafe {
        let ram_boundary = *(0x0000_0000 as *const u32);
        let _crash = *(ram_boundary as *const u32);
    }

    loop {}
}
</code></pre>
<p>Let' run the program under the debugger on real hardware.</p>
<pre><code># On another terminal
$ [sudo] openocd (..)
</code></pre>
<pre><code>$ arm-none-eabi-gdb target/cortex-m3/debug/app
</code></pre>
<pre><code>(gdb) target remote :3333
(gdb) load
(gdb) step
9               let ram_boundary = *(0x0000_0000 as *const u32)
(gdb) step
10              let _crash = *(ram_boundary as *const u32)
(gdb) print/x ram_boundary
$1 = 0x20002000
(gdb) step
app::exception::handler () at src/main.rs:19
19                  asm!(&quot;bkpt&quot;)
</code></pre>
<p>Remember that the address <code>0x0000_0000</code> is the first element of the vector table and contains the
highest RAM address. Dereferencing that address (<code>ram_boundary</code>) will load memory beyond the RAM
region.</p>
<p>Upon trying to read invalid memory, the processor raises <em>an</em> exception (we don't know <em>which</em> one)
and then proceeds to execute the <code>exception::handler</code>. While executing the handler, the processor
encounters the <code>bkpt</code> instruction, halts and yields control back to the debugger.</p>
<p>We'll use this very simple exception handler to uncover programming mistakes while debugging. We'll
revisit the exception handler in the future to make it tell us which exception was raised and which
instruction (and line of code) generated the exception.</p>
<h2>Homework</h2>
<p>What do you think would have happened if we executed the last <code>start</code> function that reads memory
beyond the RAM boundary <strong>if</strong> we didn't <em>install</em> the exception handlers, or IOW if we didn't add
the <code>exceptions</code> section or the <code>EXCEPTIONS</code> variable to our program?</p>
<blockquote>
<p><strong>HINT</strong> Look at the disassembly (<code>objdump</code>) of such binary. Take note of the addresses. What does
the vector table look like?</p>
</blockquote>
<blockquote>
<p><strong>WARNING</strong> Don't actually run a program that raises a hardware exception but doesn't handle it!</p>
</blockquote>
<h1>Blinking an LED</h1>
<p>(with too many hexadecimals)</p>
<blockquote>
<p><strong>HEADS UP</strong> Most of the links in this page are PDFs!</p>
</blockquote>
<p>So far we have only used the processor inside our microcontroller. The processor can only do math
and logic, and, on its own, it can't interact with the external world: it can't drive a LED or a
motor, read a sensor or communicate with other devices.</p>
<p>To make our programs more useful (and fun!) we must learn to use <em>peripherals</em>. A peripheral is an
extra piece of electronics that's built, alongside the processor, in the same microcontroller
package. Peripherals give the processor the extra functionality it needs to interact with the
external world.</p>
<blockquote>
<p>Awesome, what can I do with these peripherals?</p>
</blockquote>
<p>All sort of things! There are several different types of peripherals, each one provides a different
functionality. Microcontrollers manufacturers call them by different names even if the provide the
same functionality though. Here are some of the most common ones (using STM32 naming convention):</p>
<ul>
<li><code>GPIO</code>. General Purpose Input/Output. Can be used to turn on/off external devices (e.g. a motor, a
lamp, etc.) or to read the state of a &quot;switch&quot; (e.g. a two-state (ON/OFF) switch, a keyboard,
etc.).</li>
<li><code>ADC</code>. Analog-to-Digital Converter. Can be used to &quot;read&quot; analog sensors (e.g. a thermometer, a
light (intensity) sensor, etc.) or signals (e.g. voltage level of a battery, electric current,
etc.).</li>
<li><code>TIM</code>. Timers. Can be used to perform periodic tasks (e.g. every 100 ms), measure lengths of time
(e.g. for how long was this button pressed?) or generate periodic signals with variable
<a href="https://en.wikipedia.org/wiki/Duty_cycle">duty cycle</a> (AKA <a href="https://en.wikipedia.org/wiki/Pulse-width_modulation">Pulse Width Modulation</a> (PWM)). PWM is mainly used to control how much
power is supplied to an electric machine like a motor which, in turn, lets you indirectly control
other parameters like speed and torque.</li>
</ul>
<p>We'll explore these and several other peripherals in more detail in a <a href="/peripherals.html">later chapter</a>.</p>
<blockquote>
<p>So, how do I use these peripherals?</p>
</blockquote>
<p>Thanks to some magic called <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory mapped I/O</a>, to the processor, peripherals appear as
memory regions (!). This means that, for example, by writing to some special memory address you can
use the digital I/O peripheral to turn on/off a LED. Another example: By reading from some special
memory address you can use the Analog to Digital Converter peripheral to &quot;read&quot; an analog sensor
like a thermometer and get the current environment temperature as a digital/discrete value.</p>
<p>A chunk of memory associated to a single peripheral is known as a &quot;register block&quot;.  As other types
of memory, these regions are usually accessed in word (32-bit on ARM) sized chunks. Each of these
word sized chunks is referred to as a (hardware) register; though registers can also be half-word or
byte sized. Each of these registers has a human-friendly name and an address associated to it.</p>
<p>A concrete example: The STM32F100 microcontroller has a peripheral known as Reset and Clock Control
(RCC). The register block associated with this peripheral starts at address <code>0x4002_10000</code>. This
register block is comprised of several registers as seen on its <a href="http://www.st.com/content/ccc/resource/technical/document/reference_manual/a2/2d/02/4b/78/57/41/a3/CD00246267.pdf/files/CD00246267.pdf/jcr:content/translations/en.CD00246267.pdf#page=99&amp;zoom=auto,67,754">register map</a>. One of registers
associated with this peripheral is the <a href="http://www.st.com/content/ccc/resource/technical/document/reference_manual/a2/2d/02/4b/78/57/41/a3/CD00246267.pdf/files/CD00246267.pdf/jcr:content/translations/en.CD00246267.pdf#page=90&amp;zoom=auto,67,754">&quot;APB2 peripheral clock enable register&quot;</a> (AKA
<code>APB2ENR</code>) which lives at address <code>0x4002_1004</code>. This particular register can be used to power
on/off other peripherals.</p>
<p>To get familiar with the use of peripherals, we'll write the microcontroller version of the &quot;hello
world&quot; program: Blinking an LED.</p>
<h2>The device-agnostic plan</h2>
<p>This is an overview of what our program will do:</p>
<ol>
<li>Power on the digital output peripheral.</li>
</ol>
<p>To save energy, most of the peripherals in a microcontroller boot in a powered off state. We have to
explicitly &quot;turn on&quot; the peripherals we want to use.</p>
<ol start="2">
<li>Put the <em>pin</em> that's connected to the LED in <em>output mode</em>.</li>
</ol>
<p>A microcontroller pin is a exposed metal contact that can be electrically connected to another
device. A pin can either be in input mode or in output mode, but it must be in output mode to be
able to drive (supply current to) an external device. Most pins boot in input mode to avoid
spuriously driving external devices.</p>
<ol start="3">
<li>Set the pin <em>high</em> or <em>low</em> to turn on the LED.</li>
</ol>
<p><em>Low</em> means outputting zero volts (0V) on the pin whereas <em>high</em> means outputting a non-zero
voltage, usually the power supply voltage (3.3V on most Cortex-M micros), on the pin. Depending on
how the LED is wired to the pin, setting the pin low/high should turn it off/on or vice versa.</p>
<p>After we've confirmed that we can turn the LED on/off, we'll modify the program to toggle the state
of the LED pin every few seconds.</p>
<h2>The device-specific details</h2>
<p>Now we must fill in the device-specific details to realize our plan. All the needed information will
come from the microcontroller reference manual (<a href="http://www.st.com/content/ccc/resource/technical/document/reference_manual/a2/2d/02/4b/78/57/41/a3/CD00246267.pdf/files/CD00246267.pdf/jcr:content/translations/en.CD00246267.pdf">here's mine</a>) and the dev board user manual
(<a href="http://www.st.com/content/ccc/resource/technical/document/user_manual/f3/16/fb/63/d6/3d/45/aa/CD00267113.pdf/files/CD00267113.pdf/jcr:content/translations/en.CD00267113.pdf">here's mine</a>).</p>
<h3>Which LED, which pin?</h3>
<p>First, we must pick a LED on the dev board to work with. Your dev board very likely has at least one
&quot;user LED&quot; that's connected to one of the microcontroller's pin (check its user manual). Don't
confuse an &quot;user LED&quot; with the &quot;power LED&quot;. The latter is an indicator of whether the board is
powered on or off and can't be controlled by the microcontroller.</p>
<blockquote>
<p><strong>TODO</strong> What do I do if my dev board doesn't have an &quot;user LED&quot;?</p>
</blockquote>
<p>The STM32VLDISCOVERY has <a href="http://www.st.com/content/ccc/resource/technical/document/user_manual/f3/16/fb/63/d6/3d/45/aa/CD00267113.pdf/files/CD00267113.pdf/jcr:content/translations/en.CD00267113.pdf#page=11&amp;zoom=auto,67,278">two user LEDs</a>: one green and one blue. For this example, I'll be
using the blue one which is connected to the pin <em>PC8</em>. Because micros have many I/O pins, these
pins are usually grouped in <em>ports</em>. A port is a collection of 8, 16, or some other number of pins.
Ports are usually identified with letters: A, B, etc. and the pins in it are usually identified with
numbers: 0, 1, etc. Therefore, you can think of the the pin PC8 as the 9th (because numbering starts
at 0) pin in the port C.</p>
<h3>How to power up a peripheral?</h3>
<p>Micros have a dedicated peripheral that's in charge of &quot;clocking&quot; other peripherals. Clocking in
this context means powering on/off a peripheral.
A peripheral that doesn't receive a clock signal is basically powered off -- it can't be used and it
doesn't (actively) consume energy.</p>
<p>For STM32 micros this peripheral is called <a href="http://www.st.com/content/ccc/resource/technical/document/reference_manual/a2/2d/02/4b/78/57/41/a3/CD00246267.pdf/files/CD00246267.pdf/jcr:content/translations/en.CD00246267.pdf#page=69&amp;zoom=auto,67,755">RCC</a>. The family of <code>*ENR</code> registers in this peripheral
control the clocking of other peripherals. In my case, I'm interested in the <a href="http://www.st.com/content/ccc/resource/technical/document/reference_manual/a2/2d/02/4b/78/57/41/a3/CD00246267.pdf/files/CD00246267.pdf/jcr:content/translations/en.CD00246267.pdf#page=90&amp;zoom=auto,67,754">APB2ENR</a> register
which contains a <code>IOPCEN</code> bit that controls the clocking of the <code>GPIOC</code> port.</p>
<h3>How to put the pin in output mode?</h3>
<p>In my case, I need to put the pin <code>PC8</code> in output mode. Some register in the <a href="http://www.st.com/content/ccc/resource/technical/document/reference_manual/a2/2d/02/4b/78/57/41/a3/CD00246267.pdf/files/CD00246267.pdf/jcr:content/translations/en.CD00246267.pdf#page=100&amp;zoom=auto,67,755">GPIO</a> peripheral
should let me do that. After looking through the documentation, I found that the <code>CR*</code> registers do
that. In particular, the <a href="http://www.st.com/content/ccc/resource/technical/document/reference_manual/a2/2d/02/4b/78/57/41/a3/CD00246267.pdf/files/CD00246267.pdf/jcr:content/translations/en.CD00246267.pdf#page=112&amp;zoom=auto,67,754">CRH</a> register contains two bitfields: <code>CNF8</code> and <code>MODE8</code> which control the
pin <code>PC8</code>. I'll use the following combination:</p>
<ul>
<li><code>MODE8 = 0b10</code> Puts the pin in output mode and caps the toggling speed to 2MHz.</li>
<li><code>CNF8 = 0b00</code> Puts the pin in general purpose push-pull output mode.</li>
</ul>
<h3>Driving the pin high and low</h3>
<p>Again the register that I want must be in the <code>GPIOC</code> peripheral. In this case, it's the <code>BSRR</code>
register. It can individually <em>set</em> or <em>reset</em> a pin. Here, <em>reset</em> means putting the pin low and
<em>set</em> means driving the pin high.</p>
<h2>Putting it all together</h2>
<p>Here's a detailed specification of the program:</p>
<ol>
<li>Turn on the GPIOC peripheral: Set the <code>IOPCEN</code> bit in the <code>RCC-&gt;APB2ENR</code> register to <code>1</code>.</li>
<li>Put the PC8 pin in output mode: Set the <code>MODE8</code> and <code>CNF8</code> bitfields in the <code>GPIOC-&gt;CRH</code> register
to <code>0b10</code> and <code>0b00</code> respectively.</li>
<li>Set the PC8 pin high: Set the <code>BS8</code> bit in the <code>GPIOC-&gt;BSRR</code> register to <code>1</code>.</li>
<li>Set the PC8 pin low: Set the <code>BR8</code> bit in the <code>GPIOC-&gt;BSRR</code> register to <code>1</code>.</li>
</ol>
<h2>The code</h2>
<p>And here's the code. I'm omitting the <code>exceptions</code>, <code>vector_table</code> and <code>lang_items</code> modules haven't
changed since <a href="./exceptions.html#Installing%20the%20exception%20handlers">our previous program</a>.</p>
<pre><code class="language-rust">#[no_mangle]
pub fn start() -&gt; ! {
    turn_on_gpioc();
    put_pc8_in_output_mode();
    set_pc8_high();
    set_pc8_low();

    loop {}
}

fn turn_on_gpioc() {
    /// Start address of the RCC register block
    const RCC: u32 = 0x4002_1000;

    /// Offset address of the APB2ENR register
    const RCC_APB2ENR: u32 = 0x18;

    /// IOPCEN bit mask
    const RCC_APB2ENR_IOPCEN: u32 = 1 &lt;&lt; 4;

    unsafe {
        // Pointer to the APB2ENR register
        let apb2enr = (RCC + RCC_APB2ENR) as *mut u32;

        // IOPECN = 1
        *apb2enr |= RCC_APB2ENR_IOPCEN;
    }
}

/// Start address of the GPIOC register block
const GPIOC: u32 = 0x4001_1000;

/// Offset address of the BSRR register
const GPIOC_BSRR: u32 = 0x10;

fn put_pc8_in_output_mode() {
    /// Offset address of the CRH register
    const GPIOC_CRH: u32 = 0x4;

    unsafe {
        // Pointer to the CRH register
        let crh = (GPIOC + GPIOC_CRH) as *mut u32;

        // CNF8 = 0b00, MODE8 = 0b10
        *crh = *crh &amp; !0b1111 | 0b0010;
    }
}

fn set_pc8_high() {
    unsafe {
        // Pointer to the BSRR register
        let bsrr = (GPIOC + GPIOC_BSRR) as *mut u32;

        // BS8 = 1
        *bsrr = 1 &lt;&lt; 8;
    }
}

fn set_pc8_low() {
    unsafe {
        // Pointer to the BSRR register
        let bsrr = (GPIOC + GPIOC_BSRR) as *mut u32;

        // BR8 = 1
        *bsrr = 1 &lt;&lt; (16 + 8);
    }
}
</code></pre>
<p>Quite unsightly, right? So many magic values. In a <a href="/peripherals.html">later chapter</a>, we'll refactor this code to get
rid of the magic values, the pointer arithmetic and the raw pointers. The final code will look like
<a href="https://github.com/japaric/cu/blob/master/src/bin/01-led.rs">this</a>. But this code will make do for now!</p>
<h2>Test it</h2>
<p>Time to test our code! Don't feel discouraged if your program crashes or doesn't work on the first
try! I certainly get most of my embedded programs wrong when I'm just starting to write drivers and
have to deal with all these magic values and/or have to jump back and forth between the
microcontroller reference manual and my library/program.</p>
<p>OK, here's how I'd debug this program:</p>
<ol>
<li>
<p>Starting from the program entry point, <code>start</code>, repeatedly <code>step</code> over the program until you hit
the the &quot;set the pin high&quot; statement, in my case this is the <code>*bsrr = 1 &lt;&lt; 8</code>. If you didn't hit
an exception, congratulations! Head to step 3, otherwise go to step 2.</p>
</li>
<li>
<p>If you hit an exception, you should now know which statement triggered it. Reset your
microcontroller with <code>monitor reset halt</code>, then step all the way until your reach the faulty
statement but don't execute it!. At this point, inspect the address of the register that will be
modified by the faulty statement. Is the address right/valid? If not, fix it then go to step 1.</p>
</li>
<li>
<p>You should now be about to execute the instruction that sets the LED pin high. Step from here all
the way to the endless <code>loop</code>. This should toggle the state of the LED at least once. If it
doesn't, then quite a few things could have gone wrong ... See below:</p>
</li>
</ol>
<ul>
<li>Wrong register address as seen in step 2.</li>
<li><code>GPIO</code> has not been powered on or configured properly. You'll have to &quot;examine&quot; (<code>(gdb) x $ADDRESS</code>) all the related registers.</li>
<li>You are driving the wrong pin, i.e. one that's not connected to an LED. Confirm this against your
dev board user manual.</li>
</ul>
<h2>Adding a loop</h2>
<p>Now that we know that we can toggle the state of the LED. Making the LED blink is relatively easy.
We need to add a <code>delay</code> function and then move the LED toggling code inside a loop:</p>
<pre><code class="language-rust">#[no_mangle]
pub fn start() -&gt; ! {
    turn_on_gpioc();
    put_pc8_in_output_mode();

    let mut ticks = 100_000;
    loop {
        set_pc8_high();
        delay(ticks);
        set_pc8_low();
        delay(ticks);
    }
}

fn delay(n: u32) {
    for _ in 0..n {}
}
</code></pre>
<p>I have no way of telling you what value of <code>n</code> will give you e.g. a delay of 1 second because that
depends on the built-in internal clock of your microcontroller (mine is 8 MHz) and the actual
instructions that <code>delay</code> compiles to in debug mode. However, using a value between <code>10_000</code> and
<code>100_000</code> for <code>ticks</code> should make the LED blink at a visible rate.</p>
<p>Trying to compile this program as usual will give an undefined reference linker error:</p>
<pre><code>$ xargo build --target $TARGET
</code></pre>
<pre><code>error: linking with `arm-none-eabi-gcc` failed: exit code: 1
core.0.rs:(.text._ZN4core9panicking9panic_fmt17he746d5e431b5481eE+0x24): undefined reference to `rust_begin_unwind'`
</code></pre>
<p>I'm not quite sure why this happens but you can work around this problem if you disable overflow
checks:</p>
<pre><code>$ xargo rustc --target $TARGET -- -C debug-assertions=off
</code></pre>
<h2>Test it again</h2>
<p>To test, simply flash the program and let it run from the debugger:</p>
<pre><code>(gdb) continue
</code></pre>
<p>You should now see the LED blink at some rate. To make the LED blink faster make the value of
<code>ticks</code> smaller. To do this, first manually break the program by pressing <code>Crtl-C</code> at <code>gdb</code>'s
prompt, then use the following commands:</p>
<pre><code>(gdb) # break somewhere inside the loop
(gdb) break src/main.rs:13
(gdb) continue
Breakpoint 1, app::start () at (..)/src/main.rs:13
13              set_pc8_high()
(gdb) # make ticks smaller
(gdb) set ticks = 20000
(gdb) # clear breakpoint
(gdb) clear src/main.rs:13
(gdb) continue
</code></pre>
<p>The LED should now blink at a faster rate. You can repeat the experiment but setting <code>ticks</code> to a
larger value.</p>
<h1>(Mis)Optimization</h1>
<p>Surprise: Enabling optimizations (<code>--release</code>) optimizes away our whole program!</p>
<p>Solution:</p>
<ul>
<li>Split program into a library to avoid the aggressive pre-linking removal of symbols.</li>
<li>Use volatile loads/stores to prevent the compiler from optimizing away/coalescing memory accesses.</li>
<li>Add linker script assertions to avoid future misoptimizations.</li>
</ul>
<h1>Zero-cost type-safe register manipulation</h1>
<p>Goals:</p>
<ul>
<li>Go from hexadecimal gibberish to structs.</li>
<li>Prevent writing to read-only registers and viceversa.</li>
<li>Prevent reading to,writing to or modifying reserved bits.</li>
<li>Nicer debugging experience: <code>print GPIOA</code> -&gt; you get all the registers in that register block and
their values.</li>
</ul>
<h1>Abstracting Hardware</h1>
<p>Goals:</p>
<ul>
<li>A device-agnostic API.</li>
</ul>
<h1>Peripherals</h1>
<p>Overview of other common peripherals:</p>
<ul>
<li>USART/UART/Serial</li>
<li>SPI</li>
<li>I2C</li>
<li>GPIO</li>
<li>Timers + PWM</li>
<li>ADC</li>
<li>DAC</li>
</ul>
<h1>Unwritten topics</h1>
<ul>
<li>More debugging patterns: breakpoints, watchpoints, <code>bkpt</code>, etc.</li>
<li>The <code>.data</code> and <code>.bss</code> sections: <code>static</code> variables, linker script (again) and initialization
routine.</li>
<li>Guaranteed <code>panic!</code>-free programs with this one weird trick!</li>
<li>The Rust allocator interface.</li>
<li>Debug prints with ITM (Instrumentation Trace Macrocell)</li>
<li>&quot;Apps&quot;
<ul>
<li>Heartbeat LED</li>
<li>Read an analog sensor. e.g. just potentiometer, a photoresistor or a CNY70.</li>
<li>Read a digital sensor via SPI or I2C. e.g. motion sensor.</li>
<li>Data acquisition. e.g. sensor + serial comm</li>
<li>Move a servomotor</li>
<li>Open loop control system. e.g. serial comm + servo or potentiometer + servo</li>
<li>Closed loop control system. e.g. servo + magnetometer</li>
</ul>
</li>
<li>Interfacing external devices
<ul>
<li>Buttons and debouncing.</li>
<li>Servomotors.</li>
</ul>
</li>
<li>Async and concurrency
<ul>
<li>Scheduling strategies: Super loop, cooperative, preemptive.</li>
<li>Interrupts: <code>asm!(&quot;cpsid i&quot;)</code>, <code>asm!(&quot;cpsie i&quot;)</code>, data races and atomic operations.</li>
<li>DMA</li>
</ul>
</li>
<li>FPU</li>
<li><code>nm -C --size-sort</code>: binary size profiling</li>
<li><code>nm -C</code>: global vs local text symbol</li>
<li>librarify: src/lib.rs + src/bin/*.rs. Uses <code>extern</code> (lib) and <code>no_mangle</code> (bin) symbol. Basically
the library says: you (the binary) must give me a symbol with this <em>unmangled</em> name. Downside:
types signatures are lost. How to recover them? traits? Related: weak symbols for e.g. exceptions.</li>
<li>ARM calling convention:
<ul>
<li>cf. http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042f/IHI0042F_aapcs.pdf</li>
<li>A diagram of how the stack, the heap and static variables (.data, .bss) are allocated in RAM.</li>
<li>An explanation of how the call stack works: stack pointer, stack frames, what happens when a
function/interrupt is called, etc.</li>
<li>How arguments are passed to functions: via stack, registers</li>
</ul>
</li>
<li>mention that a section can't exceed its region capacity. This is automatically enforced by the
linker based on what the linker script says.</li>
<li>bluetooth: HC-06. <code>rfcomm bind rfcomm0 $ADDRESS</code></li>
<li>document other flashing methods: ELF -&gt; <code>objcopy</code> -&gt; binary, then directly flash the binary using
OpenOCD (without <code>gdb</code>) or st-link.</li>
<li>revisit the default exception handler: where did we come from? (inspect stack) which exception is
this? (inspect NVIC(?) register).
<ul>
<li>cf. http://www.freertos.org/Debugging-Hard-Faults-On-Cortex-M-Microcontrollers.html</li>
</ul>
</li>
<li>embedding Rust in C frameworks like FreeRTOS or the Photon.
<ul>
<li>cf. https://github.com/japaric/photon</li>
</ul>
</li>
</ul>
<h1>Resources</h1>
<h2>Cortex-M</h2>
<p>The ultimate source of information about this processor family is the <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.set.cortexm/index.html">ARM info center</a>.</p>
<p>Some documents of interest:</p>
<ul>
<li><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.set.cortexm/index.html">Cortex-M0 Devices - Generic User Guide</a>. About the Cortex-M0 processor, its instruction set
and its peripherals.</li>
<li><a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0662b/DUI0662B_cortex_m0p_r0p1_dgug.pdf">Cortex-M0+ Devices - Generic User Guide</a>. Same as above but for the Cortex-M0+.</li>
<li><a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0552a/DUI0552A_cortex_m3_dgug.pdf">Cortex-M3 Devices - Generic User Guide</a>. Same as above but for the Cortex-M3.</li>
<li><a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0553a/DUI0553A_cortex_m4_dgug.pdf">Cortex-M4 Devices - Generic User Guide</a>. Same as above but for the Cortex-M4.</li>
<li><a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0646a/DUI0646A_cortex_m7_dgug.pdf">Cortex-M7 Devices - Generic User Guide</a>. Same as above but for the Cortex-M7.</li>
<li><a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042f/IHI0042F_aapcs.pdf">Procedure Call Standard for the ARM Architecture</a>. About the machine registers, how
subroutines are called, how their parameters are passed and how their results are returned.</li>
<li><a href="http://infocenter.arm.com/help/topic/com.arm.doc.dai0298a/DAI0298A_cortex_m4f_lazy_stacking_and_context_switching.pdf">Lazy Stacking and Context Switching</a>. How the processor automatically decides when (not) to
save floating-point registers on the stack during interrupts. Important if implementing an OS, as
one should re-implement this functionality in their context switching logic to keep context
switching times small.</li>
</ul>
<h2>LM3S6965EVB</h2>
<p>This is the evaluation board we'll emulate using QEMU. It contains an LM3S6965 microcontroller. The
most important bits of documentation related to this board are:</p>
<ul>
<li>The <a href="http://infocenter.arm.com/help/topic/com.arm.doc.dai0298a/DAI0298A_cortex_m4f_lazy_stacking_and_context_switching.pdf">Microcontroller data sheet</a>. It contains the register maps and the descriptions of all the
device peripherals.</li>
<li>The <a href="http://www.ti.com/lit/ug/spmu029a/spmu029a.pdf">Evaluation Board User manual</a>. Description of the physical board.</li>
</ul>
<h2>Similar/related projects</h2>
<h3><code>zinc</code></h3>
<blockquote>
<p>The bare metal stack for rust</p>
</blockquote>
<p><a href="https://github.com/hackndev/zinc">GitHub</a></p>
<p>The Zinc project was the pioneer in the embedded Rust space. I have borrowed a lot of ideas from
there (like building executables using only Cargo) to write this book.</p>
<h3>Hanno Braun's blog</h3>
<blockquote>
<p>&quot;I'm teaching myself embedded programming, and I've decided to write about every step of the way&quot;</p>
</blockquote>
<p><a href="http://embedded.hannobraun.de/">Website</a></p>
<p><a href="https://github.com/hannobraun/embedded">GitHub repository</a></p>
<p>Hanno is also exploring this space but using an Arduino Due. Definitely worth checking out!</p>
<h3>RustyGecko</h3>
<blockquote>
<p>Developing Rust on Bare-Metal - An experimental embedded software platform</p>
</blockquote>
<p><a href="https://brage.bibsys.no/xmlui/handle/11250/2352353">Abstract and full text PDF</a></p>
<p><a href="https://github.com/RustyGecko">GitHub repositories</a></p>
<p>A master thesis about using Rust to develop software for the Cortex-M3 based EFM32GG
microcontroller. I found the section about &quot;Handling interrupts with Closures&quot; and the discussion
about &quot;Avoiding Mutable Aliases to Hardware&quot; particularly interesting! The authors have also put
their code up on GitHub.</p>
<h1>FAQ</h1>
<h2>Can I use my Arduino to follow this material?</h2>
<p>If you have an Arduino Due then the answer is yes.</p>
<p>The other Arduinos have AVR processors and <code>rustc</code> can't compile programs for that architecture yet.
See <a href="./why-arm.html">Why ARM Cortex-M micros?</a> for more details.</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
